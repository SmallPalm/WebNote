# 6月

## 6月展望

- [ ] 基础掌握React

# **6.11日**

今天是第一天 希望还不太晚

日记结合给自己定一些目标

### 今日任务

- [x] 全部掌握React的中的受控组件和非受控组件

受控组件 : 使用value 和 onChange事件

非受控组件: 使用createRef() 和 defaultValue 

### 今日阅读

#### AI为什么需要GPU而不是CPU?

###### **1. GPU和CPU的区别**

**GPU**

- GPU的起源确实是基于图形处理的需求。

  > [!TIP]
  >
  > 早期还没有专门GPU时，我们打游戏所有的逻辑处理都放在CPU执行，CPU的处理能力越来越强，但经不住游戏画面增长的更快，这就对图形处理提出了更高的要求。

- GPU最初开发用于生成计算机图形

  - 是具有专用内存的专用处理器
  - 通常执行渲染图形所需的浮点运算

**CPU**

- CPU又被称为通用处理器，因为它几乎可以运行任何类型的计算

  > [!Tip]
  >
  > CPU通常只有几个内核，即使是服务器专用的CPU也不过几十个内核，与GPU动辄成百上千个内核相比完全不是一个数量级

- 这并不意味着CPU不够好，CPU内核虽然更少, 但比数千个GPU内核更强大

  > [!Tip]
  >
  > 例如同时处理操作系统、处理电子表格、播放高清视频、提取大型zip文件，这些是GPU根本无法完成的

总结

- CPU最擅长按顺序处理单个更复杂的计算，而GPU更擅长并行处理多个但更简单的计算。
  - CPU运行任何类型的计算
  - GPU运行渲染图形所需的浮点运算

------

> 尽管 CPU（中央处理单元）具有更高的单线程性能和更复杂的控制逻辑，但其架构主要针对通用计算任务进行优化。CPU 通常包含较少的核心，并且每个核心的并行计算能力有限，这使得 CPU 在处理大规模并行任务（如深度学习训练）时效率较低。

###### **2. AI与GPU**

1. 主要是 **GPU** 在处理大规模 **并行计算** 方面有优势
   - **并行处理能力**：
     - 现代 GPU 可以同时处理多个数据流。
     - 深度学习模型的训练过程通常涉及矩阵乘法和向量运算，操作在 GPU 上**并行执行**，可以显著加速计算过程
     - 理解
       - 因为训练AI模型的过程需要同时对所有数据样本执行几乎相同的操作, 而GPU的架构设计具有快速同时处理多个任务所需的并行处理能力
2. GPU 的架构使其能够以高吞吐量执行大规模的数学运算。这对训练大型神经网络至关重要，因为这些网络需要处理大量的数据和复杂的计算。
3. GPU的专一处理计算性

# 6.12日

### 今日任务

- [ ] 掌握React的高阶组件

  进一步给组件添加东西

### 今日阅读

#### **Mysql入门**

**Mysql是关系型数据库**

- 关系型数据库就是表格的概念
- 关系型数据库由一个或数个表格组成
  - 表头: header
    - 每列的名称
  - 列 : row
    - 具有相同数据类型的数据的集合
  - 行 : col
    - 每一行用来描述某个人/物的具体信息
  - 值 : value
    - 行的具体信息, 每个值必须与该列的数据类型相同
  - 建 : key
    - 表中用来识别某个特定的人\物的方法, 键的值在当前列中具有唯一性

> 标识符由字母、数字或下划线(_)组成, 且第一个字符必须是字母或下划线。

**Mysql语句**

- MySQL语句是组成MySQL脚本的基本单位, 每条语句能完成特定的操作,
- MySQL语句是由 SQL 标准语句 + MySQL 扩展语句组成。

**Mysql函数**

- MySQL函数用来实现数据库操作的一些高级功能,
- 这些函数大致分为以下几类: 
  - 字符串函数、数学函数、日期时间函数
  - 搜索函数、加密函数、信息函数。

**MySQL中的数据类型**

- MySQL有三大类数据类型, 分别为数字、日期\时间、字符串,
  - 这三大类中又更细致的划分了许多子类型

数字类型

- 整数类型 :  主要区别在于存储大小和范围 : 区分有无符号
  - tinyint : **TINYINT** : 1个字节 范围(-128~127)
  - smallint : **SMALLINT** : 2个字节 范围(-32768~32767)
  - mediumint: **MEDIUMINT**:   3个字节 范围(-8388608~8388607)
  - int : **INT 或 INTEGER** :  4个字节 范围(-2147483648~2147483647)
  - bigint : **BIGINT** :  8个字节 范围(+-9.22*10的18次方)
- 浮点数类型
  - float :精度: 非精确，可能会产生舍入误差
    - 存储大小: 4 字节（单精度）
  - double : 精度: 非精确，可能会产生舍入误差
    - 存储大小: 8 字节（双精度）
  - decimal : 精度: 精确，不会产生舍入误差（在指定的精度范围内）

日期和时间

- date : 日期
- time : 时间
- datetime : 日期时间
- timestamp : 时间戳
  - 自动存储记录修改时间
- year : 年

字符串

- 字符串: char、varchar
- 文本: tinytext、text、mediumtext、longtext
- 二进制(可用来存储图片、音乐等): tinyblob、blob、mediumblob、longblob

**MySQL关键字**

- NULL
  - 数据列允许包含NULL值
- NOT NULL
  - 数据列不允许包含NULL值
- DEFAULT
  - 默认值
- PRIMARY KEY
  - 主键
- AUTO_INCREMENT
  - 自动递增, 适用于整数类型
- UNSIGNED
  - 无符号
- CHARACTER SET name
  - 指定一个字符集

**MySQL语句**

- 创建数据库语句

> create database 数据库名 [其他选项];
>
> create datebase index_first character set utf-8;

character set utf-8 将数据库字符编码指定为utf-8

**注意:** MySQL语句以分号(;)作为语句的结束, 若在语句结尾不添加分号时, 命令提示符会以 -> 提示你继续输入(有个别特例, 但加分号是一定不会错的);

**提示:** 可以使用 show databases; 命令查看已经创建了哪些数据库。

- 选择需要操作的数据库

> use index_first

创建数据库表

创建 students 表为例, 表中将存放 学号(id)、姓名(name)、性别(sex)、年龄(age)、联系电话(tel) 这些内容

```mysql
create table students
(
	id int unsigned not null auto_increment primary key
  name char(8) not null
  sex char(4) not null
  age tinyint unsigned not null
  tel char(13) null default '-'
)

/**
id为列的名称;
int指定该列的类型为 int(取值范围为 -8388608到8388607), 在后面我们又用 unsigned加以修饰, 表示该类型为无符号型, 此时该列的取值范围为 0到16777215;
not null说明该列的值不能为空, 必须要填, 如果不指定该属性, 默认可为空;
auto_increment需在整数列中使用, 其作用是在插入数据时若该列为 NULL, MySQL将自动产生一个比现存值更大的唯一标识符值。在每张表中仅能有一个这样的值且所在列必须为索引列。
primary key表示该列是表的主键, 本列的值必须唯一, MySQL将自动索引该列。
char(8) 表示存储的字符长度为8, 
tinyint的取值范围为 -127到128, 
default 属性指定当该列值为空时的默认值。
*/
```

##### 操作数据库

**向表中插入数据**

insert语句 : 用来将一行或多行数据插到数据库表中

> insert [into] 表名 [(列名1, 列名2, 列名3, ...)] values (值1, 值2, 值3, ...);

- 其中 [] 内的内容是可选的, 例如, 要给 samp_db 数据库中的 students 表插入一条记录, 执行语句: 
  - insert into students values(NULL, "王刚", "男", 20, "13811371377");
    - 默认按照列的顺序
- 有时我们只需要插入部分数据, 或者不按照列的顺序进行插入, 可以使用这样的形式进行插入:
  - insert into students (name, sex, age) values('里尼克',  '女' , 21)

**查询表中数据**

select 语句 : 常用来根据一定的查询规则到数据库中获取数据

> select 列名称 from 表名称 [查询条件];

- 查询 students 表中所有学生的名字和年龄
  - 输入语句
  - select name, age from students
- 使用通配符 * 查询表中所有的内容,
  - 语句:
  - select * from students;

**按特定条件查询**

where关键字 : 指定查询条件

> select 列名称 from 表名称 where 条件;

- 查询所有性别为女的信息为例
  - select * from students where sex="女"

where 子句不仅仅支持 “where 列名 = 值” 这种名等于值的查询形式

对一般的比较运算的运算符都是支持的,

例如  =、>、<、>=、<、!= 以及一些扩展运算符 is [not] null、in、like 等等。

 还可以对查询条件使用 or 和 and 进行组合查询

例

- 查询年龄在21岁以上的所有人信息: 
  - select * from students where age > 21;
- 查询名字中带有 “王” 字的所有人信息: 
  - select * from students where name like “%王%”;
- 查询id小于5且年龄大于20的所有人信息: 
  - select * from students where id<5 and age>20;

**更新表中数据**

update 语句 : 可用来修改表中的数据

> update 表名称 set 列名称=新值 where 更新条件;

- 将id为5的手机号改为默认的”-“
  - update students set tel=default where id=5;
- 将所有人的年龄增加1
  -  update students set age=age+1;
- 将手机号为 13288097888 的姓名改为 “张伟鹏”, 年龄改为 19: 
  - update students set name=”张伟鹏”, age=19 where tel=”13288097888″;

**删除表中的数据**

delete 语句 : 用于删除表中的数据

> delete from 表名称 where 删除条件;

- 删除id为2的行:
  - delete from students where id=2;
- 删除所有年龄小于21岁的数据: 
  - delete from students where age<20;
- 删除表中的所有数据:
  -  delete from students;

##### 对表的修改

alter table 语句 : 用于创建后对表的修改

**添加列**

> alter table 表名 add 列名 列数据类型 [after 插入位置]

- 在表的最后追加列 address地址
  - alter table students add address char(60) 默认最后插入
- 在名age的列后面插入列 birthday生日
  - alter table students add birthday data after age

**修改列**

> alter table 表明 change 列名 列新名称 新数据类型

- 将表 tel 列改名为 telphone
  - alter table students change tel telphone char(13) default '-'
- 将name列的数据类型改为char(16)
  - alter table students change name name char(16) not null;

**删除列**

> alter table 表名 drop 列名称

-  删除birthday列
  - alter table students drop birthday

**重命名表**

> alter table 表名 rename 新表名
>
> rename : 重新命名

- 重命名students 为 workmates(同事)
  - alter table students rename workmates

**删除整张表**

> drop table 表名

- 删除workmates表
  - drop table workmates

**删除整个数据库**

> drop database 数据库名

- 删除 index_first数据库 
  - drop database index_first





# 6.13日

### 今日任务

- [ ] 掌握React的Rortals

  多个App根
- [ ] 掌握React的fragment

  fragment == template
- [ ] 掌握React的严格模式
- [ ] 掌握React的动画实现

### 今日阅读

阅读《少有人走的路》

从第一张我就看到作者用大量的例子来告诉我们乐观的心态的好处, 用强大的文字的力量, 来浇灌我们的心灵, 可一个精神内耗自己都看不清自己想要什么, 懦弱, 不敢接受现实, 躲藏在自己安全屋中不敢初见天日的人又怎能改变自己的心态. 

根深蒂固的知道, 自己的心态不管有什么用, 改变不了自己无能狂怒的姿态

### 今日名句

把时间和精力投入到能够长期产生价值的事情

敏于行而慎于言





# 6.14日

- 直到下午3.42我一直在看言情小说.... 浪费时间, 可以我就是能沉浸其中, 这肯能我现在想找对象了吧

### 今日任务

- [ ] 之前的任务都没有完成 我真是克制不住自己欲望

### 今日阅读

- 了解了解世界的汇率
- 理解Vue3中的Hooks和React中的Hooks的区别

- Vue中常使用的Hooks
  - Ref和Reactive : 用于定义响应式数据
  - 生命周期钩子 : 如onMounted , onUpdated , onUnmounted
  - 依赖注入`provide`和提供`inject` : 用于在组件之间共享数据

> Vue3中常用的Hooks : 就是将可复用的逻辑提取到函数中

与React的hooks区别

- API设计
  - Vue的Composition API 使用的是函数: 如 `Ref` `Reactive`  
  - React中的Hooks使用`useState` `useEffect` 来管理状态
- 响应式系统
  - Vue 3有一个内置的响应式系统，使用 `ref` 和 `reactive` 可以非常方便地创建响应式数据
  - React中需要依靠 `useState` 和 `useReducer` 来管理状态
- 模板系统
  - Vue使用模板语法（类似HTML）
  - React使用JSX。 
    - Vue中的模板语法允许在模板中直接使用组合API的数据。
- 依赖注入
  -  Vue提供了 `provide` 和 `inject` 来实现依赖注入
  - React没有类似的内置机制
    - 但可以通过Context API实现类似的功能。

# 6.15日

无, 星期六, 浪费了一天时间

# 6.16日

无, 星期日, 喝酒休息, 浪费了一天时间

# 6.17日

### 今日阅读

##### React中的使用闭包的场景

- 在React中, 闭包是一种常见的技术，用于处理组件内部的状态和行为

- **事件处理函数**：

  -  在事件处理函数中使用闭包，可以在函数内部访问组件的状态和属性，而无需将所有状态作为参数传递。这样可以避免不必要的状态传递和提升性能。

  ```react
  import React, { useState } from 'react';
  
  function Counter() {
    const [count, setCount] = useState(0);
  //handleClick 函数使用了闭包来访问 count 和 setCoun t。
    const handleClick = () => {
      setCount(prevCount => prevCount + 1);
    };
  
    return (
      <div>
        <p>Count: {count}</p>
        <button onClick={handleClick}>Increment</button>
      </div>
    );
  }
  ```







# 6.18日

还没有将之前的任务完成

# 6.19日

- [x] 掌握React的高阶组件

- [x] 掌握React的Rortals

  多个App根

- [x] 掌握React的fragment

  fragment == template

- [x] 掌握React的严格模式

  更多的是禁用一些过时API, 因为这些API不在维护

- [x] 掌握React的动画实现

  react-transition-group插件
