# 认识组件的嵌套

- 前面我们是将所有的逻辑放到一个App.vue中
- 如果我们一个应用程序**将所有的逻辑都放在一个组件**中
  - 那么这个组件就会**变成非常的臃肿和难以维护*
- 所以组件化的核心思想应该**是对组件进行拆分**
  - **拆分成一个个小的组件**
  - 在将这些组件组合嵌套在一起
  - 最终形成我们的应用程序

## **组件的拆分**

![image-20231211121703524](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231211121703524.png)

- 如上的拆分方式后，我们开发对应的逻辑只需要去对应的组件编写就可

# 组件的通信

- 在开发过程中
  - 我们会经常遇到需要**组件之间相互进行通信**
  - 通信 : 相互传递数据
- 也可能是子组件中发生了事件
  - 需要由父组件来完成某些操作
  - 那就需要子组件向父组件传递事件

## 父子组件之间通信

- 父组件传递给子组件：通过props属性
- 子组件传递给父组件：通过$emit触发事件

![image-20231211121918387](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231211121918387.png)

# 父组件传递给子组件

- 父组件有一些数据，需要子组件来进行展示
  - 通过props来完成组件之间的通信

# Props

- Props是你可以在**组件上注册一些自定义的attribute**
  - attribute :  属性
- 父组件**给这些attribute赋值**
  - 子组件通过**attribute的名称获取到对应的值**
- Props有两种常见的用法
  - 方式一
    - 字符串数组
    - 数组中的**字符串就是attribute的名称**
  - 方式二
    - 对象类型
    - 对象类型我们可以在指定attribute名称的同时
      - 指定它需要**传递的类型**、**是否是必要的**、**默认值**等等；

## Props对象用法

- 数组用法中我们**只能说明传入的attribute的名称**
  - 并**不能对其进行任何形式的限制**
- 指定传入的attribute的类型
  - type : string

- attribute是否是必传的

  - # required : boolean类型

- attribute的默认值

  - default :   “默认值”
    - 默认值 : 数组形式 : 默认返回一个空数组
      - default : ( ) => []
    - 默认值 : 对象形式  : 默认返回一个对象
      - default : ( ) => {}

- type类型

  - String
  - Number
  - Boolean
  - Array
  - Objcet
  - Date
  - Function
  - Symbol

细节写法

1. ![image-20231211122949367](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231211122949367.png)
2. ![image-20231211123031943](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231211123031943.png)

## Prop 的大小写命名

- HTML 中的 attribute 名是大小写不敏感的
  - 所以浏览器会把所有大写字符解释为小写字符
- 这意味着当你使用 DOM 中的模板时
  - 使用camelCase (驼峰命名法) 的 prop 名
  - 需要使用其等价的
  - kebab-case (短横线分隔命名)命名

## 非Prop的Attribute

- 什么是非Prop的Attribute
  - 当我们传递给一个组件某个属性
    - 但是该属性并没有定义对应的props或者emits时
      - 就称之为 **非Prop的Attribute**
  -  父组件传递但子组件没有props接收的属性

- 如果当前的属性是一个非props的Attribute属性
  - 那么该属性就会默认被添加到子组件的根元素的

## 禁用Attribute继承

- 如果我们**不希望组件的根元素继承attribute**
  - 可以在组件中设置 **inheritAttrs: false**
- 禁用attribute继承的常见情况
  - 是需要将attribute应用于根元素之外的其他元素

当我们禁用时 , 也可以通过$attrs来访问 , 只是不自动继承了

- 我们可以通过 $attrs来访问所有的 非props的attribute

## 多根节点

- 多个根节点的attribute如果没有显示的绑定
  - 那么会报警告
- 我们必须手动的指定要绑定到哪一个属性上



# 子组件传递给父组件

- 什么情况下子组件需要传递内容到父组件呢

  - 当子组件有一些事件发生的时候
    - 比如在组件中发生了点击，父组件需要切换内容

  - 子组件有一些内容想要传递给父组件的时候

- 传递父组件 : 使用this.$emit

  - 我们需要在子组件中定义好在某些情况下触发的事件名称
  - 在父组件中以v-on的方式传入要监听的事件名称，并且绑定到对应的方法中
  - 在子组件中发生某个事件的时候，使用this.$emit根据事件名称触发对应的事件
  - ![image-20231212095820830](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231212095820830.png)



# 非父子组件的通信

- 在开发中，我们构建了组件树之后
  - 除了**父子组件之间的通信**之外
  - 还会有**非父子组件之间**的通信。

- 主要有两种方式：

  - 全局事件总线

  - Provide/Inject

# Provide和Inject

- Provide / inject 用于非父子组件之间共享数据
  - 比如有一些深度嵌套的组件
    - 子组件想要获取父组件的部分内容

  - 这种情况下, 如果我们仍然将props沿着组件链逐级传递
    - 就会非常的麻烦

- 对于这种情况下
  - 我们可以使用ProVide和 Inject
    - provide 就行在一个组件中提供数据
    - inject 在一个组件中进行接受数据

  - 无论层级结构有多深
    - 父组件都可以作为其**所有子组件的依赖提供者**

  - 父组件有一个provide 选项来**提供数据**
  - 子组件有一个inject 选项来开始使用这些数据

- 实际上 ,依赖注入看作是long range props
  - 父组件不需要知道那些 子组件使用它 provide 的 property
  - 子组件不需要知道 inject 的 property 来自那里


## provide和inject基本使用

![image-20231213210907284](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231213210907284.png)

# Provide和inject函数写法

- 如果Provide中提供的一些数据是**来自data**，那么我们可能会想要**通过this来获取**
  - 
  - 
  - 需要使用函数
  - 绑定provide



# 处理响应式数据

- 在Provide中的数据并不是响应式数据
- 需要使用computed 的函数来进行监听
  - 进行数据发生改变就进行重新计算
    - 给inject中传递发生改变
- 而computed返回的是一个ref对象
  - 需要取出其中的value值
    - 才可以看见数据中的内容



# 全局事件总线Mitt库

- Vue3从实例中移除了 \$on , \$off 和 \$once 方法
  - 所有想要继续使用全局事件总线 , 要通过第三方库
- 安装第三方库
- 使用eventBus.js
  - 将EventBus构造函数 导出出去
- 然后再项目中导入
  - 进行使用
- eventBus.on(事件名 , 事件函数) 进行在事件总线中记录
- eventBus.emit (事件名) , 进行在事件总线中调用
- eventBus.off (事件名 , 事件函数) 进行在事件总线在函数移除掉

