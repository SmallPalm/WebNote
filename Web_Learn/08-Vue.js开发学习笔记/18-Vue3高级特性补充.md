

# 认识自定义指令

- Vue可以来自定义自己的指令
  - 注意
    - 在Vue中
    - **代码的复用和抽象主要还是通过组件**

  - 通常在某些情况下
    - 你需要对DOM元素进行底层操作
    - 这个时候就会用到自定义指令

- 自定义指令分为两种
  - 自定义局部指令
    - 在组件中optionsAPI通过 directives 选项 
      -  只能在当前组件中使用

    - 但是在setup函数中
      - 是定义变量
        - 细节查询代码

  - 自定义全局指令
    - app的 directive 方法 , 可以在任意组件中被使用

  - 




# 指定的生命周期

**一个指令定义的对象，Vue提供了如下的几个钩子函数**

- **created**：在绑定元素的 attribute 或事件监听器被应用之前调用
  - 就是这个元素div被已经被创建了
    - 但是这个元素div的属性
      - 如ref , class中所代表的CSS样式, JS代码还没有应用
      - 只是仅仅元素被创建出来而已 , 元素的属性没有执行, 渲染
- **beforeMount**：当**V-指令第一次绑定到元素**并且在**挂载父组件之前**调用
  - 就是即将挂载当前元素或当前组件时, 函数发生回调
- **mounted**：在**绑定元素**的父组件**被挂载后调用**
  - 就是当前元素或当前组件被挂载后, 函数发生回调
- **beforeUpdate**：在更新包含组件的 VNode 之前调用
  - 当元素或组件中的内容进行更新, 改变时, 函数发生回调
- **updated**：在包含组件的 VNode **及其子组件的 VNode** 更新后调用
  - 当元素或组件中的内容更新改变完成之后, 函数发生回调
- **beforeUnmount**：在卸载绑定元素的父组件之前调用；
  - 卸载元素或组件之前
- **unmounted**：当指令与元素解除绑定且父组件已卸载时，只调用一次
  - 卸载元素或组件之后



# 指令的参数和修饰符

- 指令可以接受一些参数或者修饰符
- 在我们的生命周期中
  - 我们可以**通过 bindings 获取传入的参数 - 修饰符 - 值等内容**
  - ![image-20240123164126457](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240123164126457.png)

## bindings对象中的值

![image-20240123164038012](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240123164038012.png)

## 自定义指令练习

**时间戳的显示**

![image-20240123164429502](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240123164429502.png)





# Vue内置组件

## Teleport

-  在组件化开发中，我们**封装一个组件A**，在**另外一个组件B中使用**
  - 那么组件A中template的元素
    - 会被挂载到组件B中template的某个位置
  - 最终我们的应用程序会形成**一颗DOM树结构**
- 但是某些情况下
  - 我们希望**组件不是挂载在这个组件树上**的
  - 可能是**移动到Vue app之外的其他位置**
    -  比如**移动到body元素**上
      - 或者我们**有其他的div#app之外的元素**上
    -  这个时候就需要通过teleport来完成

**Teleport是什么**

- 它是一个Vue提供的内置组件，类似于react的Portals
- teleport翻译过来是心灵传输、远距离运输的意思
- teltport有两个属性
  - to : 指定将其中的内容移动到目标元素
    - 可以使用class选择器 , ID选择器
  - disabled : 是否禁用teleport的功能

**实现效果**

![image-20240123165120874](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240123165120874.png)



可以在 teleport 中使用组件，并且也可以给他传入一些数据

- ![image-20240123165228801](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240123165228801.png)



## **多个teleport**组件

- 如果我们将**多个teleport应用**到**同一个目标上（to的值相同）**
  - 那么这些**目标会进行合并**
  - ![image-20240123165347528](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240123165347528.png)



# 异步组件Suspense

**Suspense显示的是一个实验性的特性，API随时可能会修改**

- **Suspense是一个内置的全局组件，该组件有两个插槽：**
  - default：如果default可以显示，那么显示default的内容；
  - fallback：如果default无法显示，那么会显示fallback插槽的内容；
  - ![image-20240123165545938](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240123165545938.png)



# 认识use插件

- 通常我们**向Vue全局添加一些功能**时
  - 会采用use插件的模式，它有两种编写方式
- 对象类型
  - 一个对象
    - 但是必须包含一个 install 的函数 : 会传入一个app参数
    - 该函数会在安装插件时执行
- 函数类型 : 一个function : 会传入一个app参数
  - 这个函数会在安装插件时自动执行

- use插件可以**完成的功能没有限制**
  - 添加全局方法或者 property
    - 通过把它们添加到 config.globalProperties 上实现
  -  添加全局资源：指令/过滤器/过渡
  - 通过全局 mixin 来添加一些组件选项
  - 一个库，提供自己的 AP
    - 同时提供上面提到的一个或多个功能
- ![image-20240123172239473](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240123172239473.png)



# 认识h函数

1. **template 转换成 render函数 在转换成 VNode** 
2. **一个个VNode在组成一个VDOM树**
3. **VDOM树转换成真实DOM树**



1. ![image-20240124105139404](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240124105139404.png)



- Vue推荐在绝大数情况下**使用模板**来创建你的HTML
  - 然后一些特殊的场景
  - 如果需要**JavaScript的完全编程的能力**
    - 这个时候你可以使用 **渲染函数** 
      - 它**比模板更接近编译器**
- VNode和VDOM的概念
  - Vue在生成真实的DOM之前，会将我们的节点转换成VNode
    - 而VNode组合在一起形成一颗树结构
    - 就是虚拟DOM（VDOM）
    - 事实上，我们之前编写的 template 中的HTML 
      - 最终也是使用**渲染函数**生成对应的VNode

    - 那么，如果你想充分的利用JavaScript的编程能力
      - 我们可以自己来编写 createVNode 函数，生成对应的VNode

- **使用 h()函数**
  -  h() 函数是一个用于创建 vnode 的一个函数
  - 其实更准备的命名是 createVNode() 函数
    - 但是为了简便在Vue将之简化为 h() 函数




# h函数

- 看文档
- ![image-20240127083632355](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240127083632355.png)

![image-20240127083649752](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240127083649752.png)

# jsx的babel配置

- template -> 转化 -> vue-loader

  render    -> 不需要转化

  jsx -> 转化 -> babel

  babel 可以转化

  - ES6 -> ES5
  - ts -> js
  - jsx -> js




- 如果我们希望**在项目中使用jsx**，那么我们**需要添加对jsx的支持**

  - jsx我们通常会通过Babel来进行转换
    - React编写的jsx就是通过babel转换的
  - 对于Vue来说
    - 我们只需要在Babel中配置对应的插件即可

- 安装**Babel支持Vue的jsx插件** : Vue-Cli

  - npm install @vue/babel-plugin-jsx -D

- **如果是Vite环境，需要安装插件**

  - **npm install @vitejs/plugin-vue-jsx -D**

  ![image-20240127083829410](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240127083829410.png)



![image-20240127083844777](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240127083844777.png)

# 
