# 模板语法

- 在React中编写开发html文件
  - 是通过jsx语法来编写开发html
    - 所以对应的代码都是编写的类似于js的一种语法
  - 之后通过Babel将jsx编译成 React.createElement 函数调用
- Vue也支持jsx的开发模式
- 但是大多数情况下，使用基于HTML的模板语法
- 在模板中
  - 允许开发者以**声明式**的方式
    - 将DOM和底层组件实例的数据绑定在一起
  -  在底层的实现中
    - Vue将模板编译成虚拟DOM渲染函数

# 动态内容

## Mustache插值语法

- 如果我们希望把数据显示到模板（template）中
  - 使用最多的语法是 “Mustache” 插值语法 (双大括号)
-  并且data返回的对象是有添加到Vue的响应式系统中
- 当data中的数据发生改变时
  - 对应的内容也会发生更新
- Mustache插值语法中不仅仅可以是data中的属性
  - 也可以是一个JavaScript的表达式

## V-once

- v-once用于指定元素或者组件只渲染一次
  - 当数据发生第二次变化时
    - 元素或者组件以及其所有的子元素将视为静态内容并且跳过
  - 该指令可以用于性能优化
- 如果是子节点，也是只会渲染一次
- 从 3.2 起，
  - 可以搭配 [`v-memo`](https://cn.vuejs.org/api/built-in-directives.html#v-memo) 的无效条件来缓存部分模板


## V-text

- 用于更新元素的 textContent

​       

## V-html

- 默认情况下，如果我们展示的内容本身是 html的
  - 那么**vue并不会对其进行特殊的解析**
- 如果我们希望这个内容被Vue可以解析出来
  - 那么可以使用 v-html 来展示

## V-pre

- 用于跳过元素和它的子元素的编译过程
  - 显示原始的Mustache标签
  - 跳过不需要编译的节点，加快编译的速度

## V-cloak

- 保持在元素上直到关联组件实例结束编译
  - 和 CSS 规则如 [v-cloak] { display: none } 一起用时
- 这个指令可以**隐藏未编译的 Mustache 标签直到组件实例准备完毕**
- 到组件实例解析过慢, html中的插值语法会优先显示
  - 这时使用cloak, 组件实例没有解析出来时
    - html中的插值语法也会优先隐藏

# V-memo

- 需要传入一个固定长度的依赖值数组进行比较。
- 如果数组里的每个值都与最后一次的渲染相同，
- 那么整个子树的更新将被跳过。
- 当组件重新渲染，如果 内容 都保持不变
  - 这个元素中及其子项的所有更新都将被跳过 , 不会重新渲染
- 如果`v-memo` 传入空依赖数组 (`v-memo="[]"`) 将与 `v-once` 效果相同

# 动态属性

## V-bind

除了内容需要动态来决定外，某些属性我们也希望动态来绑定

- 主要用来绑定动态属性 ： v-bind
  - 比如动态绑定a元素的href属性
  - 比如动态绑定img元素的src属性
- 绑定属性我们使用v-bind
  -  缩写：: 
    - 对应的**语法糖**，也就是简写方式
  - 用法
    - 动态地绑定一个或多个 attribute （属性）
      - 或一个组件 prop 到表达式

V-bind用于绑定一个或多个属性值，或者向另一个组件传递props值

**有哪些属性需要动态**

- 比如图片的链接src、网站的链接href、动态绑定一些类、样式等等

**绑定class有两种方式：**

- 对象语法
- 数组语法

**绑定style**

- 利用v-bind:style来绑定一些CSS内联样式
- CSS property 名
  - 可以用驼峰式 (camelCase)
  - 或短横线分隔 (kebab-case，记得用引号括起来) 来命名

**绑定style有两种方式：**

- 对象语法
- 数组语法

# 动态绑定属性

- 在某些情况下，我们属性的名称可能也不是固定的
  - 前端我们无论绑定src、href、class、style，属性名称都是固定的
- 如果属性名称不是固定的，我们可以使用 :[属性名]=“值” 的格式来定义
  - 这种绑定的方式，我们称之为动态绑定属性

# 绑定对象

将一个对象的所有属性，绑定到html元素上的所有属性

**绑定对象给组件传递参数**

- 以直接使用 v-bind 绑定一个 对象

- ```vue
  V-bind = "info对象"
  ```




# V-on

监听用户发生的事件

- 当通过methods中定义方法
  - 以供@click调用时，需要注意参数问题

情况一

- 如果该方法不需要额外参数
  - 那么方法后的()可以不添加
- 但是注意
  - 方法**本身中有一个参数**
    - 那么会默认将**原生事件event参数**传递进去

情况二

- 如果需要同时传入多个参数
  - 同时需要event时
    - 需要通过$event传入事件

v-on支持修饰符，修饰符相当于对事件进行了一些特殊的处理

- stop - 调用 event.stopPropagation()。
- .prevent - 调用 event.preventDefault()。
- .capture - 添加事件侦听器时使用 capture 模式。
- .self - 只当事件是从侦听器绑定的元素本身触发时才触发回调。
- .{keyAlias} - 仅当事件是从特定键触发时才触发回调。
- .once - 只触发一次回调。
- .left - 只当点击鼠标左键时触发。
- .right - 只当点击鼠标右键时触发。
- .middle - 只当点击鼠标中键时触发
- .passive - { passive: true } 模式添加侦听器



# V-if

**根据当前的条件决定某些元素或组件是否渲染**

- v-if
- v-else
- v-else-if

- **用于根据条件来渲染某一块的内容：**
  - 这些内容只有在条件为true时，才会被渲染出来

**v-if的渲染原理：**

- v-if是惰性的；
- 当条件为false时
  - 其判断的内容**完全不会被渲染**或者**会被销毁掉**；
- 当条件为true时
  - 才会真正渲染条件块中的内容；

- v-show
  - v-show是不支持template
  - v-show不可以和v-else一起使用
  - 隐藏方式
    - 使用Css中的display中none
  - 无论是否需要显示到浏览器上
    - 它的DOM实际都是有存在的
    - 只是通过CSS的display属性来进行切换显示隐藏





## v-show和v-if的区别

v-show

-  v-show元素无论是否需要显示到浏览器上，它的DOM实际都是有存在的，只是通过CSS的display属性来进行切换

v-if

- 当条件为false时，其对应的原生压根不会被渲染到DOM中

意思

- v-show隐藏但依然存在DOM元素中
- v-if隐藏是直接将DOM元素销毁



- **开发中如何进行选择呢？**
- 如果我们的原生需要在显示和隐藏之间**频繁的切换**
  - 那么使用v-show
- 如果**不会频繁的发生**切换
  - 那么使用v-if；
