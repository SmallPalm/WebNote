# 什么是内存泄露

- 内存泄露是指**应用程序中的内存 不再被使用但仍然被占用**
  - 导致内存消耗 , 逐渐增加
    - 最终可能导致 应用程序 性能下降 或 崩溃
- 内存泄露通常是 
  - 由于开发者编写的代码**未正确释放不再需要的对象或数据而导致的**

**特征 :**   程序对内存失去控制

特征：程序对声明的变量或者数据失去控制





# 内存泄露的案例

- 意外的全家变量

```js
function someFunction() {
  // 这个变量会变成全局变量, 并可能导致内存泄露
  // 没有关键字声明
  myObject = { /* ... */}
}
```



- 闭包 : 闭包可能会无意中持有对不再需要的变量 或 对象的引用
  - 从而阻止 声明的变量 被 垃圾回收

```js
function createClosure() {
  const data = [1, 2, "/* 大量数据 */"]
  
  retrun function() {
    // 闭包仍然持有对 data 的引用, 即使它不再需要
    console.log(data)
  }
}

const closureFunction = createClosure()
// 当`closureFunction` 不再需要时, 它仍然保留着 'data' 的引用, 导致内存泄露.
```

- 事件监听器 
  - 忘记移除事件监听器可能会导致内存泄露 
  - 因为与监听器 相关联 的对象将无法被垃圾回收

```js
function createListeners() {
  const element = document.getElementById('someElement')
  element.addEventListeners('click', () => {
    //...
  })
}
createListeners()
// 即使 'someElement' 从DOM中移除, 该元素及其事件监听器仍将在内存中
```

- 循环引用
  - 对象之间的循环引用会阻止它们被垃圾回收

```js
function createCircularReferences() {
  const obj1 = {}
  const obj2 = {}
  obj1.ref = obj2
  obj2.ref = obj1
}
createCircularReferences()
// 由于循环引用, 'obj1' 和 'obj2' 都将保留在内存中
```

- setTimeout / setInterval
  - 使用setTimeout 或 setInterval 时
  - 如果没有正确清理, 可能会导致内存泄露
  - 特别是当回调函数 持有对大型对象的引用时

```js
function doSomethingRepeatedly() {
  const data = [/* 大量数据 */]
	setInterval(() => {
    // 闭包持有对data的引用, 即使它不再需要
    console.log(data)
  }, 1000)
}
doSomethingRepeatedly()
// 'doSomethingRepeatedly' 不再使用时, 定时器仍然在运行, 导致内存泄露
```

