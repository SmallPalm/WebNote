# Vue2不能监听数组下标原因

Vue2 用的是 Object.defineProperty  劫持数据 , 实现 数据视图 双向绑定

但Object defineProperty 可以 劫持数组 的

```js
const arr = [1, 2, 3, 4, 5, 6]

Object.keys(arr).forEach(function(key) {
  Object.defineProperty(arr, key, {
    get: function() {
      console.log("key", key)
    },
    set: function(value) {
      console.log(value, "Value")
    }
  })
})
```



Object.defineProperty 可以 劫持数组 但是Vue2并没有用来劫持数组

**原因**

Object.defineProperty 是属性级别 的劫持

如果通过数组下标来劫持数组, 实现数组监听

随着数组长度的增加, 会有很大的性能损耗

导致框架的性能不稳定

因此Vue2放弃一定用户便携性 , 提供了$set方法 去操作数组,

以最大程度保证了框架的性能稳定

在 Vue3 中通过使用 Proxy 得到了彻底解决，Proxy 能监听所有对象属性的变化，包括数组下标和数组长度的变化。





# Vue2和Vue3数组的响应式处理方式

在Vue2和Vue3中，对数组的响应式处理方式有所不同，主要是因为两者采用了不同的响应式机制。

### Vue2中的数组响应式处理

**Vue2的响应式机制**是基于`Object.defineProperty`，它会对对象的每个属性进行数据劫持（即“拦截”），从而实现响应式。但是，这种机制在处理数组时有一些局限性：

1. **Vue2无法直接检测数组长度的变化**：例如，直接修改`array.length`无法被侦听到。
2. **数组中的特定元素无法被自动侦听**：例如，通过索引直接修改数组元素（如`array[0] = newValue`），不会触发视图更新。

为了解决这些问题，Vue2对数组的方法进行了“包裹”，特别是以下七个变更方法：

- `push()`
- `pop()`
- `shift()`
- `unshift()`
- `splice()`
- `sort()`
- `reverse()`

这些方法被重写以触发视图更新。Vue2对数组的监听是通过劫持这些方法来实现的，而不是直接监听数组的元素变化。

**为什么Vue2这样做：**

- `Object.defineProperty`并不能检测到数组内部元素的变化，所以Vue2采取了对变更方法进行“包裹”的方式来确保变更被检测到。
- 这种方法的局限性在于，它不能监听通过索引直接改变的数组元素，也无法监听数组长度的变化。

### Vue3中的数组响应式处理

**Vue3采用了Proxy**来实现响应式系统，Proxy可以直接监听对象的操作，包括对数组的操作。这带来了更强大的功能和更灵活的监听机制。

1. **直接监听数组**：Vue3中，数组是完全响应式的，包括通过索引修改元素、直接修改`length`属性等，所有这些操作都会触发视图更新。
2. **自动侦听所有操作**：因为Proxy可以拦截几乎所有操作，Vue3不再需要对数组的变更方法进行特别处理。

**为什么Vue3采用Proxy：**

- Proxy可以彻底解决Vue2中通过`Object.defineProperty`无法监听数组变化的问题。
- Proxy能监听更多种类的操作，比如`delete`属性，动态添加属性等，使得响应式系统更为健壮。

### 总结

- **Vue2**：通过对数组方法进行“包裹”来实现部分的数组响应式，但是有一些限制。
- **Vue3**：通过Proxy实现了对数组的全面监听，解决了Vue2的局限性。



# 数组的局限性和操作的十道代码面试题

基于 Vue2 响应式系统特别是关于数组的局限性和操作的十道代码面试题。这些题目可以帮助考察候选人对 Vue2 响应式机制、数组操作以及如何规避 Vue2 的限制的理解。

### 题目 1

**问题**：在 Vue2 中，下面的代码是否会触发视图更新？如果不会，如何修复？

```
javascript
复制代码
this.items[0] = 'new value';
```

**答案**：不会触发视图更新。Vue2 不能通过数组下标检测变化。可以通过 `Vue.set` 来解决：

```
javascript
复制代码
Vue.set(this.items, 0, 'new value');
```

### 题目 2

**问题**：解释下面代码在 Vue2 中的行为，并说明如何使 `this.items.length = 0` 触发视图更新。

```
javascript
复制代码
this.items.length = 0;
```

**答案**：在 Vue2 中，直接修改数组长度不会触发视图更新。可以通过 `this.items.splice(0)` 来清空数组并触发视图更新。

### 题目 3

**问题**：为什么 Vue2 需要对数组的 `push` 方法进行重写？请给出 `push` 方法的重写代码。 **答案**：因为 Vue2 不能直接监听数组的变化，通过重写 `push` 方法，可以手动触发视图更新。重写代码如下：

```
javascript复制代码const originalPush = Array.prototype.push;
Array.prototype.push = function (...args) {
  originalPush.apply(this, args);
  // 手动触发视图更新
  this.__ob__.dep.notify();
};
```

### 题目 4

**问题**：在 Vue2 中，如何将一个新的元素插入数组的第二个位置，并确保视图更新？ **答案**：可以使用 `splice` 方法来插入，并确保触发视图更新：

```
javascript
复制代码
this.items.splice(1, 0, 'new element');
```

### 题目 5

**问题**：在 Vue2 中，解释为什么直接使用 `this.items[2] = 'new value';` 不会触发视图更新，并展示如何检测这个问题。 **答案**：因为 Vue2 无法监听通过下标直接修改数组元素的操作。要检测这个问题，可以使用 `Vue.set`：

```
javascript
复制代码
Vue.set(this.items, 2, 'new value');
```

### 题目 6

**问题**：如果需要在 Vue2 中监控数组的所有元素变化（包括通过下标直接修改），你会如何设计这个功能？ **答案**：可以通过递归地遍历数组并使用 `Vue.set` 来监控每个元素的变化。或者通过包装数组的方法来手动触发视图更新。

### 题目 7

**问题**：在 Vue2 中，给出如何在数组中移除某个元素并确保视图更新。 **答案**：可以使用 `splice` 方法移除元素：

```
javascript
复制代码
this.items.splice(index, 1);
```

### 题目 8

**问题**：在 Vue2 中，为什么 `this.items.reverse()` 能够触发视图更新，而 `this.items[0] = 'new value';` 不能？ **答案**：因为 Vue2 对 `reverse` 方法进行了重写，但无法监听通过下标直接修改数组元素的操作。`reverse` 触发视图更新是因为它调用了被重写的方法。

### 题目 9

**问题**：在 Vue2 中，如果需要对某个数组元素进行条件修改（如判断值是否为负数然后修改），并确保视图更新，你会怎么做？ **答案**：可以通过 `splice` 方法或者 `Vue.set` 来确保触发视图更新。例如：

```
javascript复制代码if (this.items[2] < 0) {
  Vue.set(this.items, 2, 0);
}
```

### 题目 10

**问题**：在 Vue2 中，如何将一个对象插入到数组的指定位置，并确保该对象的属性也能被响应式监听？ **答案**：可以通过 `splice` 方法将对象插入，并确保对象本身也是响应式的。例如：

```
javascript
复制代码
this.items.splice(2, 0, Vue.observable({ key: 'value' }));
```

这些题目涵盖了 Vue2 在处理数组响应式时的局限性及解决方案，能够考察候选人对 Vue2 响应式机制的深入理解。