# 代码共享方案

- 我们已经学习了在JavaScript中可以通过模块化的方式
  - 将代码划分成一个个小的结构
- 以后的开发中我们就可以通过模块化的方式
  - 来封装自己的代码
    - 并且封装成一个工具
  - 这个工具
    - 我们可以让同事通过导入的方式来使用

方式一

- 上传到GitHub上
  - 其他程序员通过GitHub下载我们的代码手动的引用

- 缺点是大家必须知道你的代码GitHub的地址
  - 并且从GitHub上手动下载
-  需要在自己的项目中手动的引用
  - 并且管理相关的依赖
- 不需要使用的时候
  - 需要手动来删除相关的依赖
- 当遇到版本升级或者切换时
  - 需要重复上面的操
  - 作, 极其麻烦

方式二

- 使用一个专业的工具来管理我们的代码
  - 我们通过工具将代码发布到特定的位置
- 其他程序员直接通过工具来安装、升级、删除我们的工具代码
- 通过第二种方式我们可以更好的管理自己的工具包
  - 其他人也可以更好的使用我们的工具包
- **专业的工具 : npm year pnpm npx cnpm**

# 包管理工具npm

包管理工具

- Node Package Manager : Node包管理器
- 目前不仅仅是Node包管理
  - 还有**前端项目中我们也使用它来管理依赖的包**
- 我们依赖的包有:
  - vue、vue-router、vuex、
  - express、koa、react、react-dom、
  - axios、babel、webpack等等

安装npm

- 安装Node的过程会自动安装npm工具
  - npm属于node的一个管理工具
    - npm管理的包可以查看npm包的官网
      - npmjs.org
- npm管理的包存放在那里
  - 我们发布自己的包其实是发布在**registry仓库**上面的
  - 安装一个包时其实也是从**registry仓库**上面下载的包

## npm的配置文件

- 如何使用npm来管理这么多的包
  - 事实上 , 我们每一个项目都会有一个对应的配置文件
    - 无论是前段项目还是后端项目
  - 这个配置文件会记录着项目的名称 , 版本号 , 项目描述等
  - 也会记录着
    - 项目所依赖的其他库的信息
      - 依赖库的版本号
- 这个配置文件就是package.json
- 配置文件这么创建
  1. 手动从零创建项目
     - npm init -y : 全部配置项默认yes创建 
  2. 通过vue-Cil脚手架创建项目
     1. 脚手架会帮助我们生成package.json
     2. 并且里面有相关的配置完成



## npm命令行

- npm init
  - 创建时填写信息
- npm init -y
  - 所有信息使用默认的



# 常见的配置文件的属性

- name属性
  - 项目的名称
- version属性
  - 当前项目的版本号
- Descriptor属性
  - 描述信息 : 作为项目的基本描述
- author属性
  - 作者相关信息 
    - 发布时用到
- license属性
  - 开源协议
    - 发布时用到

- private属性
  - 记录当前的项目是否是私有的
  - 当值为true时
    - npm是不能发布它的
    - 这是防止误操作将
      - 公司的私有项目或模块发布出去的方法
- **main属性**
  - 设置程序的入口
    - 当我们将使用的模块导入进来时
    - 如果有main属性
      - 会找到对应的main属性查找文件的
- **scripts属性**
  - 用于配置一些脚本命令 , 以键值对的形式存在
  - 配置后我们可以通过npm run命令的key来执行这个命令
  - npm key 和npm run key的区别
    - 一个缩写 ,一个全称 , 它们是等价的
    - 对于常用的 start , test , stop , restart可以省略掉run
      - 直接通过npm key等方式来运行
- **dependencies属性**
  - 指定无论**开发环境**还是**生产环境**都需要依赖的包
  - 通常我们项目实际开发用到的一些库的模块
    - 如 vue, vuex, vue-router, react, react-dom, axios等等
  - 使用npm install
    - 可以直接将dependencies属性记录的库下载下来
  - 默认安装开发和生产依赖
    - **npm install axios**
    - **npm i axios**
  - 根据package.json文件中的**dependencies属性**中的依赖包
    - 可以快速将所有**dependencies属性**中的依赖包下载
    - **npm install**
- **devDependencies属性**
  - 一些包在生产环境是不需要的
    - 比如webpack(打包) , babel(代码转换)等
  - 这个时候我们可以通过 npm install webpack --save--dev
    - ​	将它安装到devDependencies属性中
  - 这个属性里面的库不会上传到生产环境中
    - 这是开发环境中使用
  - 开发依赖
    - **npm install webpack --save-dev**
    - **npm install webpack -D**
    - **npm i webpack -D**
- **peerDepentdencies属性**
  - 项目的依赖关系是对等依赖
    - 也就是说依赖一个包,
      - 它必须是以另外一个框架中或者一个库中为前提下使用
  - 如 element-plus是依赖于 vue3 的
    - ant-design是依赖于react react-dom的
- **engines属性**
  - 用于指定Node和npm的版本号
  - 安装的过程中
    - 会先检查对应的引擎
- **browserslist属性**
  - 用于配置打包后的JavaScript浏览器的兼容情况
  - 否则我们需要手动的添加polyfills来让支持某些语法
  - 也就是说它是为webpack等打包工具服务的一个属性


# 依赖的版本管理

npm的包通常需要遵从semver版本规范

- semver版本规范是 X . Y . Z
  - X : 主版本号 : major
    - 当我们做了不兼容的**API修改**时 
      - 可能不兼容之前的版本
  - Y : 次版本号 : minor
    - 当我们做了向下兼容的**功能性新增**
      - **新功能增加** , 但是兼容之前的版本
  - Z : 修订号 : patch
    - 当我们做了向下兼容的**问题修正**
      - **没有新功能** ,  修复了之前版本的bug
- X.Y.Z
  - 表示一个明确的版本号
- ^X.Y.Z
  - 表示X是保持不变的
    - Y和Z永远安装最新的版本
- ~X.Y.Z
  - 表示X和Y保持不变的
    - Z永远安装最新的版本



# npm install命令

- 全局安装
  - **npm install webpack -g**
  - **npm install webpack --location=global**
    - 主要安装工具包
- 项目 (局部) 安装
  - **npm install webpack**
    - 主要安装库
  - 分为了生产依赖安装和开发依赖安装

- 全局安装是直接将某个包安装到全局
- 通常使用npm全局安装的包都是一些工具包 :yarn webpack等
  - 并不是类似于axios , Express, koa 等库文件
- 所以全局安装了之后并不能让我们在所有的项目中使用axios等库



安装webpack

安装webpack-cil

安装yarn

安装axios

## 项目安装

- 默认安装开发和生成的依赖
  - npm install axios
  - npm i axios
- 开发依赖
  - npm install axios --save-dev
  - npm install axios -D
  - npm i webpack
- 根据package.json中的依赖包
  - npm install
- 卸载某个依赖包
  - npm uninstall package
  - npm uninstall package --save-dev
  - npm uninstall package -D
- 强制重新build
  - npm rebuild
- 清除缓存
  - npm cache clean

# package-lock.json

文件解析

- name 
  - 项目的名称
- version
  - 项目的版本
- lockfileVersion
  - lock文件版本
- requires
  - 使用requires来跟踪模块的依赖关系
- dependencies
  - 当前项目依赖的包或库
- integrity
  - 用来从缓存中获取索引
    - 在通过索引去获取压缩包文件
- resolved
  - 用来记录下载的地址
    - registry仓库中的位置



# npm install原理

内部原理

- 从npm5开始 , npm支持缓存策略

![image-20231117160325397](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231117160325397.png)

解析

- npm install会检测是否有package-lock.json文件

没有lock文件时

- 分析依赖关系
  - 这是因为我们可能**下载的包**会**依赖其他的包**
    - 并且多个包之间会产生相同的依赖情况
  - 从registry仓库中下载压缩包
    - 如果我们设置了镜像
      - 那么会从镜像服务器下载压缩包
      - 镜像 : https://registry.npm.taobao.org
  - 获取到压缩包后会对压缩包进行缓存
    - 从npm5开始有的
  - 将压缩包解压到项目的node_modules文件夹中
    - require的查找顺序会在该包下查找
- 有lock文件
  - 检测lock中的包的版本是否和package.json中一致
    - 不一致 , 那么会重新构建依赖关系
      - 直接会走顶层的流程
    - 一致的情况下 , 会去优先查找缓存
      - 没有找到 , 会从registry仓库下载
        - 直接走顶层的流程
  - 查找到 , 会获取缓存中的压缩文件
    - 并且将压缩文件解压到
      - node_modules文件夹中



# yarn工具

- yarn是由Face-book , Google , Exponent 和 Tilde联合推出了
  - 一个新的JS包管理工具
- yarn 是为了弥补早期npm的一些缺陷而出现的
- 早期的npm存在很多的缺陷
  - 安装依赖速度很慢
  - 版本依赖混乱等等一系列的问题
- 虽然从npm5版本开始 , 进行了很多的升级和改进
  - 但是依然很多人喜欢使用yarn
- npm和yarn相对应的命令

![image-20231117170532363](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231117170532363.png)



# Cnpm工具

- 由于一些特殊的原因
  - 某些情况下我们没办法很好的从 https://registry.npmjs.org下载下来一些需要的包
- 可以使用npm的镜像
  - npm config get registry
- 可以直接设置npm的镜像
  - npm config set registry https://registry.npm.taobao.org
- 我们可以使用cnpm，并且将cnpm设置为淘宝的镜像
  - npm install -g cnpm --registry=https://registry.npm.taobao.org
  - cnpm config get registry # https://r.npm.taobao.org/

# npx工具

- npx是npm5.2之后自带的一个命令
  - 常见使用 : 它来调用项目中的某个局部模块的指令
- 当一个依赖包拥有全局安装和项目局部安分别还是两个版本
  - webpack为例
    - webpack 5.1.3 : 全局安装
    - webpack 3.6.0 : 项目安装
  - 如果我在终端执行 webpack -v查看版本
    - 会显示全局安装的版本 5.1.3
    - 默认运行全局命令
  - 当前目录下找不到webpack 就会去全局找 ,并且执行命令

## 局部命令的执行

- 使用局部项目的webpack依赖包

  - 方式一 : 明确查找到node_module下面的webpack
  - 方式二 : 在script定义脚本 来执行webpack

- 方式一 : 在终端中使用如下命令 (现在项目根目录下)

  ```js
  ./node_modules/.bin/webpack --version
  ```

- 方式二 : 修改package.json中的scripts

  - **在scripts脚本中自动找到的就是node_modules/.bin目录下查找对应的命令**

  ```json
  "scriprs" : {
  	"webpack" : "webpack --version"
  }
  ```

- 方式三 : 使用npx

  ```node
  npx webpack --version
  ```

  - **npx会到当前目录下的node_modules/.bin目录下查找对应的命令**

# npm发布自己的包

- 注册npm账号
- 在命令行登录
  - npm login
- 修改package.json
- 发布到npm registry上
  - npm publish
- 更新仓库
  - 修改版本号
  - 重新发布
- 删除发布的包
  - npm unpublish
  - npm deprecate
- homepage
  - 主页 : 如果对应的包有对应自己的官网
    - 填写对应的链接
- repository
  - 填写对应的git仓库的链接

# Pnpm

- pnpm : performant npm 缩写
- 速度快 , 节省磁盘空间的软件包管理器
- 快速
  - pnpm 比 其他包管理器快
- 高效
  - node_modules中的文件链接
    - 自特定的内容寻找 地址存储库
- 支持monorepos
  - pnpm内置支持单仓多包
- 严格
  - pnpm默认创建了一个非平铺的node_modules
    - 因为代码无法访问任意

# 硬链接和软链接的概念

硬链接 : hard link

- 电脑文件系统中创建的多个文件 , 程序 **平等地共享**同一个**文件存储单元**
  - 在硬盘中存储的数据 , 可以是多个文件夹一起共享
    - 但删除一个文件夹时 其他文件夹不会受到影响
      - 但是却只在内存中占一块地址
- 硬链接不可以操作目录 ,只能操作文件

软链接 : soft link

- 也称 符号链接 : Symbolic link
- 软链接是一类的特殊的文件
- 其包含有一条以绝对路径 或者 相对路径的形式
  - 指向其他文件或者目录的**引用**
- 硬盘存储中的数据 通过一个文件链接使用时
  - 然后创建了一个快捷方式
  - 这个快捷方式通过绝对路径或者相对路径
    - 可以找到这个文件夹进行使用
- 软链接和硬链接

![ ](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231120095421249.png)

## 演练

文件的拷贝

- 文件的拷贝 : 会从 硬盘中复制出来一份新的文件数据
  - 两个文件都是独立的, 不会相互影响
- window : copy foo.js(要拷贝的文件)    foo_copy.js(拷贝出来的文件)
- macos : cp foo.js(要拷贝的文件)    foo_copy.js(拷贝出来的文件)
- ![image-20231120103356993](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231120103356993.png)
- ![image-20231120103928196](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231120103928196.png)

文件的硬链接

- window : mklink /H(硬链接) aaa_hard.js(新文件名) aaa.js(原本的文件名)
- macos : ln foo.js foo_hard.js
- ![image-20231120103402961](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231120103402961.png)
- ![image-20231120104306997](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231120104306997.png)

文件的软链接

- window : mklink  aaa_soft.js aaa.js
- macos : ln -s foo.js foo_copy.js
- ![image-20231120104747850](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231120104747850.png)
- ![image-20231120104727492](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231120104727492.png)



# pnpm理解

- 当使用npm 或者 yarn时 , 如果有100个项目
  - 并且所有项目都有一个相同的依赖包
  - 那么我们的硬盘就需要保存100份相同的依赖包的副本
- 如果使用pnpm 依赖包将被存放在一个统一的位置
  - 如果对同一依赖包使用相同的版本
    - **那么磁盘上只有这个依赖包的一份文件**
    - 效率高, 节省磁盘空间
  - 如果某个依赖包包含 100 个文件，其发布了一个新版本，并且新版本中只有一个文件有修改
    - 则 `pnpm update` **只需要添加一个新文件到存储中**
      - 而不会因为一个文件的修改而保存依赖包的所有文件。
  - 如果对同一依赖包需要使用不同的版本
    - 则**仅有版本之间不同的文件会被存储起来**
  - 所有文件都保存在硬盘上的统一的位置
    - 当安装软件包时 ,其包含的所有文件都会**硬链接**到此位置
      - 只会占用一份硬盘空间 , 而不会占用额为的硬盘空间
    - 这可以让我们在项目之间方便的共享相同版本的依赖包

# pnpm创建非扁平的node_modules目录

- 当使用npm 或  yarn  安装依赖包时
  - 所有的依赖包都将被提升到node_modules的根目录下面
  - 如 安装axios依赖包
    - axios依赖包同样会依赖别的一些包
      - 依赖别的一些包 : **axios-mock-adapter**：用于模拟请求和响应
    - 而这些包和axios一起放在node_modules的根目录
- 其结果是 ,源码代码可以访问本不属于当前项目所设定的依赖包
  - **我并没有要下载或项目并不需要用的包**,  但我可以使用
    - 我可以在代码中使用调用这些其他依赖包附带下载的依赖包

## 创建非扁平化的目录

- 使用pnpm下载的依赖包
- pnpm会自动将所有下载的依赖包放进一个文件夹中
- 并且会将依赖包使用软链接的方式放入node_modules的根目录下供我们使用
- 而真正存下到文件夹中依赖包使用硬链接 链接硬盘中的数据
- 并且每一个依赖包中也会有一个node_modules
  - 这个node_modules会放入依赖包所需要的依赖包
  - 并且不会软链接
  - 所以我们就不能访问到本不属于当前项目所设定的依赖包
- ![image-20231120145323886](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231120145323886.png)



## pnpm命令

- 安装 : 全局安装
  - npm install pnpm -g
- 快速安装
  - 根据package.json文件中的**dependencies属性**中的依赖包
  - pnpm install : 快速安装所有记录的包
- 安装依赖包
  - pnpm add   ***
- 删除依赖包
  - pnpm remove ***
- 运行scripts脚本中的命令
  - pnpm ***

# pnpm的存储store

- 在pnpm7.0之前 , 依赖包的存储位置是 ~/ .pnpm-score中的
- 在pnpm7.0之后 , 统一的存储位置进行了更改 : 
  - ![image-20231120152042965](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231120152042965.png)
- 终端命令 : 获取当前活跃的store目录
  - pnpm store path
- **另外一个非常重要的store命令是prune（修剪**
  - 从store中删除当前未被引用的包来释放store的空间
  - pnpm store prune

理解

- 当下载一个依赖包时 , pnpm会创建两个硬链接方式下的依赖包文件夹
  - 一个在**当前使用的项目**的node_modules下的pnpm的文件夹下
    - 并使用非扁平化目录
  - 一个便存储在电脑中的
    - 这个方便我们在使用的找到他去做硬链接