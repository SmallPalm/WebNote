# 认识ES Module

- JavaScript没有模块化一直是它的痛点
  - 在ES6(ES2015)推出自己的模块化规范系统
- ES Module 和 CommonJS的模块化有些不同之处
  - 一方面它使用import 和 export关键字不同
    - CommonJS使用 require 和 module.exports , exports关键字
  - 另一方面它采用**编译期的静态分析**
    - 并且也加入了**动态引用的方式**
- ES Moduleh模块采用export 和 import关键字来实现模块化
  - **export负责将模块内的内容导出**
  - **import {} from “”负责从其他模块导入内容**
- 采用ES Module将自动采用严格模式 : ues strict

## 案例代码注意事项

- 使用ES Module时,不能在通过本地加载HTML文件 
  - 那样会遇到CORS错误
    - 因为本地的地址不安全
    - JavaScript模块需要安全性
  - 需要使用模块规定的协议
    - 如 : http https data等
  - 总结
    - 在我们打开对应的html时
      - 如果html中有使用模块化的代码
        - 那么必须开启一个协议服务来打开
- 在HTML中使用ES Module 需要在script标签中写入 type = “Module”
- 在浏览器中直接使用ES module时 , 必须在文件后加上文件的后缀名

# export关键字

- export关键字将一个模块中的变量 , 函数 , 类等导出
- 导出的方式

方式一

- 在语句声明的前面直接加上export关键字

方式二

- 将所有需要导出的标识符 , 放到export后面的 {} 中

  - 这里的{} 里面不是ES6的对象字面量 的增强写法
    - {}也不是表示一个对象的
      - {} 并不是我们创建出来的,
        - {}是由浏览器在解析整个模块的创建出来的对象
          - 它是一种语法结构 : 到发现导出的{} 中有标识符
          - 就允许我们先将标识符放入模块环境记录中
  - 所以 export { name: name } 是错误写法	

方式三

- 导出时给标识符起一个别名
  - 通过as关键字起别名

# import关键字

- import关键字负责从另外一个模块中导入内容
- 导入内容的方式

方式一

- import { 标识符列表 } from “模块”
  - 这里的{} 也不是一个对象,
    - 里面只是存放导入的标识符列表内容

方式二

- 导入时给标识符起别名
  - 通过as关键字起别名

方式三

- 通过 * 将模块功能放到一个模块功能对象 (标识符) 上



# export和import结合使用

补充

- export和import可以结合使用

- ```js
  export {sum as barSum} from "./foo.js"
  ```

这样的好处

- 开发和封装到一个功能库时
  - 通常我们系统将暴露的所有接口放到一个文件中
- 这样方便我们管理和查找
- 方便指定统一的接口规范
  - 也方便阅读代码

# default用法

- 前面我们学习的导出功能都是有名字的导出
  - 名字的导出 : named exports
    - 在导出export时指定了名字
    - 在导入import时需要知道具体的名字
- 还是一种导出叫做默认导出 (default export)
  - 默认导出export时 可以 不需要指定名字
  - 在导入时不需要使用 {} , 并且可以自己来指定名字
  - 它也方便我们和现有的CommonJS等规范相互操作
- 注意 : 在一个模块中,  只能有一个默认导出 (default export)

# import函数

- 通过import加载一个模块
  - 是不可以在其放到逻辑代码中的
- 为什么会出现这个情况那
  - **这是因为ES Module在被JS引擎解析时 , 就必须知道它的依赖关系**
  - **这个时候JS代码没有任何的运行**
    - 所以无法再进行类似于if判断中根据代码的执行情况
  - 甚至拼接路径的写法也是错误的
    - 因为我们必须到运行时能确定path的值
- 通过import加载一个模块时, 代码还没有执行
  - 将模块加载完成之后才会执行代码

## import meta

- import.meta是一个给JavaScript模块暴露特定上下文的元数据属性的对象。
  - 它包含了这个模块的信息，比如说这个模块的URL
  - 在ES11（ES2020）中新增的特性；



# ES Module的解析流程

- 阶段一 : 构建 
  - 根据地址查找JS文件 , 并且从服务器中下载
    - 将其解析成 **模块记录**
      - 模块记录 :Module Record
- 阶段二 : 实例化
  - 对模块记录进行实例化, 并且分配内存空间
    - 解析模块的导入和导出语句
      - 把模块指向对应的内存地址
- 阶段三 : 运行
  - 运行代码 , 计算值
    - **并且将值填充到内存地址中**

## 自己的理解

- 根据JS文件路径 , 找到文件将其下载下来 
  - 将每一个下载下来的JS文件 , 抽出模块记录
- 在对模块记录做一个实例化
  - 这个实例化的过程 , 主要是解析模块中导入导出的语法
    - 就是查看下载下来的JS文件 , 有没有导入导出别的文件
    - 如果有那就会重复执行 阶段一和阶段二
      - 在这个过程代码是不会执行的
  - 发现模块的导入 , 找到文件地址
    - 继续下载 , 继续解析模块的import和export
  - 发现模块的导出 
    - 并且有导出一个对应的标识符
      - **这会对导出的这个标识符做一个实例化**
        - 实例化一个模块环境记录
        - **模块环境记录 : 就是先将发现的标识符放到一起**
          - **然后并没有赋值**
          - 下载 , 解析, 实例化全部文件完成后
        - 进入阶段三
        - 每一个文件的代码 执行
          - 才会赋值在模块环境记录中存放的标识符
          - **赋值的标识符可以获取 ,但不可以修改**
      - 模块环境记录 : Module Environment record