# 面向对象

- 它也是一种编程方式 , 
- 就是你把你对应这些代码可以抽象成一个一个对象，各种各样的对象。
- 甚至你在做很多操作的时候，首先你第一想到的不是立马来做这个操作，
- 而是想着我怎么去创建一个类，在根据这个类去创建对应的对象，
- 用这个对象来完成某一个操作。
- 所以我们在做面向对象这个词的时候，其实我们并不是说指的是某一个具体的代码，而是一种编程方式，我们也叫做编程范式

## 面向对象三大特性

- 封装 : 我们前面将属性和方法封装到一个类中 , 可以称之为封装的过程
  - 属性可以封装到一个对象中, 在封装到一个类中

- 继承 : 继承是面向对象中非常重要的 , 不仅仅可以减少重复代码的数量
  - 也是多态的前提  (纯面向对象中)

- 多态 :  不同的对象在执行时表现出不同的形态 
- 抽象



# JavaScript中的多态

- 多态的表现 :  **JavaScript中到处都是多态**

- 维基百科对于多态的定义
  - 多态 : 指为不同数据类型的实体提供统一的接口, 
    - 或使用一个单一的符号来表示多个不同的类型
  - 不同的数据类型进行同一个操作, 表示出不同的行为 , 就是多态的体现
- 继承的多态的前提
- 在严格意义的面向对象语言中 ,  多态的是存在如下条件的
  1. 必须有继承 或者(实现接口)
  2. 必须有父类引用指向子类对象



# 继承

- 继承可以帮助我们将重复的代码和逻辑抽取到父类中,  子类只需要直接继承过来使用即可
  - 在很多编程语言中,  继承也是多态的前提



# 对象的原型链

- 一个对象上获取属性 , 如果当前对象中没有获取到就会去它的原型上面获取

```js
var obj = {
name :"limingyu",
age:"12"
}

obj.__proto___ = {
  
}
obj.__proto__.__proto__ = {
  
}
obj.__proto__.__proto__.__proto__ = {
  message : ""
}
```

- 自己创造的一个原型链
- object. prototype
  - 事实上这个原型就是我们最顶层的原型了 
- object : null prototype {} 原型有什么特殊
  - 该对象有原型属性 , 但是它的原型属性已经指向的是null  , 也就是已经是顶层原型
  - 该对象上有很多默认的属性和方法



# object是所有类的父类

- 从我们上面的object 原型我们可以得出一个结论 : 
  - 原型链最顶层的原型对象就是object的原型对象 

​	

# 对象的方法

- hasOwnProperty
  - 判断对象是否有某一个属于自己的属性(不是在原型上的属性)
- in
  - 判断某一个属性是否在某个对象或者对象的原型上
  - for in 遍历不仅仅是自己对象上的内容 ,也包括原型对象上的内容
- instanceof
  - 用于检测构造函数的prototype , 是否出现在某个实例对象的原型链上的
  - 用于判断对象和类(构造函数)之间的关系
- isPrototypeOf
  - 用于检测某个对象 , 是否出现在某个实例对象的原型链上的
  - 用于判断对象和对象之间

# 原型继承关系

- function/object/foo都是function的实例对象
- 原型对象(prototype)默认创建时, prototype的隐式原型都是指向object的显示原型的
- object是 function的父类
- object是构造函数 , 是function的创造的实例对象
  - 所以object 的 隐式原型  指向 function 的 显示原型
- 但是 function 的 显示原型  指向 object 的 显示原型
- object拥有 显示原型 和 隐式原型 
  - 而object的显示原型   也拥有 一个隐式原型
- function也是

function创建了实例对象

而所有的显示原型 最后 都会指向 object的显示原型

函数既是一个函数也是一个对象





# 构造函数的类方法

- 添加在函数原型上的方法称为 实例方法

- 添加函数对象本身的方法称为  类方法
- 实例方法 在没有实例对象的情况下 ,  是不能直接调用函数 的
  - 但类方法可以直接调用
