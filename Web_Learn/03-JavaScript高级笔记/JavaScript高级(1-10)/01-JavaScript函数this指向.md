# this到底指向什么

- 函数在调用时 , JavaScript会默认给this绑定一个值
  - this到底绑定一个什么值跟定义的位置没有关系
  - this是怎么绑定和怎么调用方式以及调用的位置是有关系的
  - this是在运行时才被绑定的

### this的绑定规则

#### 默认绑定

- 独立函数调用
  - 函数没有被绑定到某个对象上进行调用
  - 严格模式下
    - ​	独立调用的函数中的this指向的是undefined

#### 隐式绑定

- 通过某一个对象来进行调用
- 隐式绑定前提
  - 必须在调用的对象内部有一个对函数的引用(比如一个属性)
  - 如果没有这样的引用 , 在进行调用时,  会报找不到该函数的错误
  - 正是通过这个引用 ,间接的将this绑定到了这个对象上

#### 显示绑定

- 我们不希望在对象内部包含这个函数的引用 , 同时又想在这个对象上进行强制调用

- JavaScript所有的函数都可以使用**call**和**apply**方法

  - ###### apply

    - 第一个参数 : 绑定this

      - 作用 : 就是给this准备的
      - 调用函数时 , 会将this绑定到这个传入的对象上

    - 第二个参数 : 传入额外的实参 , 以数组的形式

    - ```js
      foo.apply("apply" , ["传参","形参"])
      ```

      

  - ###### call

    - 第一个参数 : 绑定this

    - 参数列表 : 后续的参数以多参数的形式传递 , 会作为实参

    - ```js
      foo.call("call" , "传参"，"形参")
      ```

  - ###### bind

    - 怪异函数对象(exotic function object)
      - 默认普通调用this也会指向对象
    - 创建一个新的绑定函数 ,提前将this绑定到一个对象上

  - 我们明确将this绑定到那个对象上面就是显示绑定

#### new绑定

- 构造函数绑定

#### 内置函数的调用绑定

- 内置函数和一些第三方库
  - 根据一些经验 , 判断this的指向



# this绑定规则优先级

- 默认规则的优先级最低
- 显示绑定优先级  >  隐式绑定
- new绑定优先级  >  隐式绑定
- new绑定 / 显示绑定
  - new不可用和apply / call 一起使用
    - 不存在谁的优先级更高
  - new绑定优先级 > bind
- bind绑定优先级 > apply / call
  - 绑定null和undefined : 这个显示绑定会直接被忽略
  -  this会直接返回window对象 : 使用默认规则
- 创建一个函数的间接引用
  - 间接函数引用 

  - 将一个函数赋值到另一个函数上面 , 依旧是这个函数本身
    - 所有是默认绑定

  - 这个情况使用默认绑定规则




# 箭头函数arrow function

- 箭头函数是ES6之后增加的一种编写函数的方法
  - 它比函数表达式要更加简洁
  - 箭头函数不会绑定this , atguments属性
  - 箭头函数不能作为构造函数来使用
    - 不能和new一起来使用

## 箭头函数的简写

1. 如果箭头函数只有一个参数 ,  那么小括号()可以省略
2. 如果函数体中只有一行执行代码 , 那么{}可以省略
3. 如果只有一行代码 , 那这行代码的表达式会作为函数的返回值
   - 默认返回
   - 就不用写return了 , 但只是一行代码可以
4. 如果默认返回值是一个对象 , 那这个对象必须要加()
   1. 因为函数执行体是一个大括号, 对象也是一个大括号
   2. 为了让js引擎解析 , 对象 这个大括号要加上小括号



# this规则之外—ES6箭头函数

- 箭头函数的作用域里面没有this
  - 自己的作用域没有this
  - 他就会去上层作用域中找
    - 然后箭头函数就会去找全局this
  - 在箭头函数中this
    - 他会一级一级作用域里面去找的
    - 如果每一级作用域里面都没有
      - 他就会找到全局作用域里面的this

