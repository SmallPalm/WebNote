# 认识内存管理

- 不管什么编程语言 , 在代码的执行过程中都是需要给它分配内存的
  - 不同的是某些编程语言需要我们手动的管理内存
  - 某些编程语言会可以自动帮助我们管理内存
- 内存的管理都会有如下的生命周期
  1. 分配申请你需要的内存(申请)
  2. 使用分配的内存(存放东西 , 比如对象)
  3. 不需要使用时 , 对其进行释放
- 手动管理内存
  - C C++
- 自动管理内存
  - Java , JavaScript , Python等
- JavaScript的内存管理是自动的
  - 原始值 , 对象 , 函数 , 这一切都会占用内存
  - 不需要手动进行管理
  - JavaScript引擎会帮我们处理好

# JavaScript的内存管理

- JavaScript会再定义数据时为我们分配内存
- JavaScript对原始数据类型
  - 内存分配会再执行时
  - 直接在栈空间进行分配
- JavaScript对复杂数据类型
  - 内存分配会再堆内存中开辟一块空间
  - 并且将这块空间的指针(堆内存的内存地址 , “0ax00”)
  - 返回值变量引用

# JavaScript的垃圾回收

- 因为内存的大小是有限的 , 所以当内存不在需要的时间
  - 我们需要对其进行释放
    - 以便腾出更多的空间
- 在**手动管理内存**的语言中 ,  我们需要通过一些方式
  - 自己来释放不再需要的内存 : 比如free函数
  - 但是这种管理方式**非常低效** , 会**影响编写逻辑代码的效率**
  - 并且对**开发者的要求也很高** , 一**不小心就会产生内存泄露**
- 现代的编程语言都是有自己的垃圾回收机制
  - 垃圾回收的英文Garbage Collection : 简称GC
  - 对那些不在使用的对象
    - 我们都简称为垃圾(garbage) ,需要回收, 以释放更多的内存空间
    - 而我们的语言运行环境 , 
      - 比如Java的运行环境**JVM**
      - JavaScript的运行环境JS引擎
        - 都会使用内存的垃圾回收器

# 常见的GC算法

### 引用计数(Reference-counting)

- 引用计数
  - 当一个对象有一个引用指向他时
    - 那么这个对象引用就+1
  - 当一个对象的引用为0时
    - 那这个对象就可以被销毁了
- 这个算法一个很大的弊端就是产生循环引用
  - obj1.info = obj2
  - obj2.info = obj1

### 标记清除(mark-Sweep)

目前v8里面最核心的GC算法

- 标记清除的核心思路是**可达性**(Reachability)
- 这个算法是设置一个**根对象**
  - 垃圾回收器会定期从这个根开始 , 找所有从根开始有引用到的对象
    - 对于没有引用到的对象 , 就认为是不可用的对象 , 然后清除
- 这个算法可以很好的解决循环引用的问题
- ![GC标记清除图](D:\OneDrive\桌面\GC标记清除图.png)



### 其他算法优化补充

- J引擎比较广泛的采用的就是**可达性中**的**标记清除算法**, 
  - 类似V8引擎为了进行更好的优化
    - 他会在算法的实现细节上也会结合一些其他的算法
- **标记整理**(Mark-Compact)
  - 和标记清除类似
  - 不同的是,回收期间同时会将保留的存储对象
    - 搬运汇集到连续的内存空间 , 从而整合空闲空间 , 避免内存碎片化
- **分代收集**(Generational collection)
  - 对象被分成两组: “新的” 和 “旧的”
  - 许多对象出现 , 完成他们的工作并很快死去 , 他们可以很快被清理
  - 那些长期存活的对象会变得 “老旧” , 而且被检查的频次也会减少
- 增量收集(incremental collection)
  - 如果有许多对象 , 并且我们试图一次遍历并标记整个对象集 , 则可能需要一些时间 , 并在执行的过程中带来明显的延迟
  - 所有JS引擎试图将垃圾收集工作**分层几部分来做**
    - 然后将**这几部分会逐一进行处理**
      - 虽然这样会有**许多微小的延迟**
        - 但并**不是一个大的延迟**
- **闲时收集**(ldle -time collection)
  - 垃圾收集器只会在CPU空闲时尝试运行,以减少可能对代码执行的影响



## V8引擎详细的内存图

![V8引擎详情内存图-堆](D:\OneDrive\桌面\V8引擎详情内存图-堆.png)