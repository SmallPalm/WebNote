# 正则表达式

- 维基百科对正则表达式的解释
  - 正则表达式  :   Regular Expression
  - 正则表达式使用单个字符串来描述 , 匹配一系列某个句法规则的字符串
    - 许多程序设计语言都是支持利用正则表达式来进行字符串的操作的
- 简单来说, 正则表达式是一种字符串匹配利器 , 可以帮助我们搜索 ,获取, 代替字符串
- 在JavaScript中正则表达式使用RegExp类来创建 , 也有对应的字面量的方式
  - 正则表达式主要由两部分组成
    - 模式 (patterns)
    - 修饰符 (flags)

# 正则表达式的使用方法

- JavaScript中的正则表达式被用于RegExp的exec和 test方法
- String的 match matchAll , replace , relaceAll , search 和 split方法

方法

- exec 和 test 是属于 RegExp 对象中的方法
- exec方法
  - 在字符串中执行查找匹配的RegExp方法
    - 它返回一个数组 ( 没有匹配到则返回null)
- **test方法**
  - 在字符串中测试是否匹配的RegExp方法
    - 它返回true或 false

以下方法属于String中的方法 

- **match**
  - 在字符串中执行查找匹配的String方法
    - 它返回一个数组 , 在未匹配到时会返回null
- matchAll
  - 在字符串中执行 查找所有匹配的String方法
    - 它返回一个迭代器
      - 注意matchAll传入的正则修饰符必须加g
      - g : global 全局
- search
  - 在字符串中测试匹配的String方法
    - 它返回匹配到的位置索引 或者在失败时返回-1
- **replace**
  - 在字符串中执行查找匹配的String方法,
    - 并且使用替换字符串
      - 替换掉匹配到的子字符串
        - 还有replaceAll方法 查找全部的 ,替换掉全部的
- **split**
  - 在使用正则表达式 , 或者一个固定字符串 ,分割一个字符串
    - 并将分隔后的子字符串存储到数组中的String方法



## 修饰符Flag的使用

- 常见的修饰符
- g : 全部的 , 匹配全部的内部  ( global )
- i  :  忽略大小写 ( ignore )
- m : 多行匹配 ( multiple )





## 规则-字符类

- 字符类 (Character Classes) 是一个特殊的符号 , 匹配特定集中的任何符号
  - \d  ( d :  digit)
    - 数字 从 0 到 9 的字符
  - \s  (  s : space)
    - 空格符号 : 包括空格 , 制表符 \t ,  换行符\n 和其他少数稀有字符 例如 \v \f 和 \r
  - \w  ( w : word)
    - 单字 字符 : 拉丁字母 或 数字 或下划线_
  -  .  (点)
    - 点 .  是一种特殊字符类, 它与 “除换行符之外的任何字符” 匹配



- 反向类 :  对比\d \s \w 反向的就是大写的
  - \D 非数字 :  除\d以外的任何字符 ,  例如字母
  - \S  非空格符号 :  除 \s 以外的任何字符 , 例如字母
  - \W 非单字字符 : 除 \w 以外的任何字符 , 例如非拉丁字母或下划线_ 或非拉丁数字
    - 就是大写的包括小写不包括的

## 规则-锚点

- 符号 ^ 和符号 $ 在正则表达式的中具有特殊的意义
  - 它们被称之为 “ 锚点 ” (Anchors)
  - 符号 ^ 匹配文本的开头
  - 符号 $ 匹配文本的末尾
- 词边界 **\b**
  - 词边界 \b  是一种检查 , 就像 ^ 和 $ 一样 , 它会检查 字符串中的位置是否为词边界
  - 词边界测试 \b 检查位置的一侧是否匹配 \w , 而另一侧则不匹配 \w
    - \b 就是表示 将单词隔开, 不能有 \w的包括的字符 , 跟^和$一样限制周边

## 规则-转义字符

- 如果要把特殊字符作为常规字符来使用
  - 需要对其进行转义
    - 需要在特殊字符的前面加 上 反斜杠 \
- 常见需要转义的字符
  - [] \ ^ $ . | ? * + ( )



## 集合和范围

- 有时候我们只要选择多个匹配字符的其中之一就可以
  - 在方括号 [...] 中的几个字符或者字符类意味着
    - 搜索给定的字符中的任意一个就可以
- **集合(Stes)**
  - 比如说 , [lmy] 意味着查找 在3个字符 中的任意一个就可以
- **范围(Ranges)**
  - 方括号也可以包含字符范围
  - 比如说 , [ a-z ] 会匹配从a到z范围内的字母, [0-9] 表示从0到9的数字
  - [0-9A-Z] 表示两个范围 : 它搜索一个字符, 满足数组0到9 或者大写字母A到Z
  - \d —— 和[0-9]相同
  - \w —— 和 [a-z A-Z 0-9 _ ] 相同
- 排除范围 : 除了普通的范围匹配 , 还有类似 \[^...] 的 “排除” 范围匹配
  - \d -> 表示的是 [0-9]  /D 表示不是0-9 -> 所有 [ ^0-9 ]表示非0-9

# 量词

- 假设我们有一个字符串 +7(903)-123-45-67 , 并且想要找到它包含的所有数字
  - 因为它们的数量是不同的 , 所有我们需要给与数量一个范围
  - 用来形容我们所需要的数量的词被称之为量词 ( Quantifiers)
- 数量 {n}
  - 确切的位数 : {5}
  - 某个范围的位数 : {3,5}
- 缩写
  - +: 代表 “ 一个或多个 ” 相对于 {1, }
  - ? : 代表 “ 零个或一个” 相当于 { 0,1} 换句话说 , 它使得符号变得可选
  - *: 代表 “零个或多个”  相当于 {0, } 也就是说 , 这个字符可以多次出现或不出现

# 贪婪和惰性模式

- 默认情况下的匹配规则是找到匹配的内容后, 会继续向后查找, 一直找到最后一个匹配的内容
  - 这种匹配方式,  我们称之为贪婪模式
- 懒惰模式中的量词 与 贪婪默认中的是相反的
  - 只要获取到对应的内容后, 就不在继续向后匹配
  - 我们可以在量词后面在加一个问号 ? 来再次启用懒惰模式
  - 所有匹配模式变为 *? 或 +? 甚至将 “?” 变为 ??

## 捕获组

- 模式的一部分可以用括号括起来 (...)  这称之为 “  捕获组 ( capturing group )”

- 作用

  1. 它允许将匹配的一部分作为结果数组中的单独项
  2. 它将括号视为一个整体

- 方法 string.match(RegExp) ,如果 RegExp没有 g(全局匹配) 标志 , 将查找第一个匹配并将它作为一个数组返回

  - 在索引0 : 完全匹配
  - 在索引1 : 第一个括号的内容
  - 在索引2 : 第二个括号的内容
  - 等等

- 命名组

  - 用数组记录组很困难

  - 对于更复制的模式,  计算括号很不方便. 我们有一个更好的选择,  给括号起个名字

  - 这个通过在开始括号之后立即放置 ?\<name>来完成的

    - ```js
      const res = message.match(/(?<我是捕获组的名字>)/)
      ```

- 非捕获组

  - 有时我们需要括号才能正确应用量词 , 但我们不希望它们的内容出现在结果中
  - 可以通过在括号的开头添加 ?: 来排除组

- or是正则表达式中的一个术语 , 实际上是一个简单的 “或”

  - 在正则表达式中, 他用竖线 | 表示
  - 通常会和捕获组一起来使用, 在其中表示多个值
