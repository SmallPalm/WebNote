# 字符串模板基本使用

- ES6允许我们使用字符串模板来嵌入
  - JS的变量 , 函数 表达式 , 三元运算符 来进行拼接
- 使用`` 符号来编写字符串 , 称之为模板字符串
- 在模板字符串中,  我们可以通过 ${ expression (表达)} 来嵌入动态的内容



# 标签模板字符串使用

- 模板字符串还用另一种用法 :  标签模板字符串
- 使用标签模板字符串 , 并且在调用的使用插入其他变量
  - 模板字符串被拆分了
  - 第一个元素是数组 , 是被模块字符串拆分的字符串组合
  - 后面的元素是一个个模块字符串传入的内容
- 在React的styled-components库 中会使用到 函数``的拼接



# 函数的增强

- 在ES6之前 , 我们编写的函数参数是没有默认值的, 所有我们在编写函数时

  - 传入了参数 , 使用传入的参数
  - 没有传入参数 , 那么使用一个默认值

- 在ES6中, 我们允许直接给函数一个默认值

  - 就是新增了一种简便的写法

  - ```js
    function foo(x = 20, y =30){
      console.log(x+y)
    }
    
    foo(20 , 34)
    foo()
    ```

- 有默认参数的形参尽量写到后面

- 有默认参数的形参 , 是不会计算到length之内的

  - 并且后面所有的参数都不会计算在length之内

- 剩余参数也是放到后面

  - 但是默认参数在剩余参赛的前面

- ```js
  //剩余参数
  ...agms
  //默认参数
  agms = '默认值'
  ```



# 函数的剩余参数

- ES6中引用rest parameter , 可以将不定数量的参数放入到一个数组中
  - 如果最后一个参数是 ... 为前缀的 , 那么它会将剩余的参数放到该参数中 , 并且作为一个数组
- 剩余参数和 arguments 有什么区别
  - 剩余参数只包含那些没有对应形参的实参,
    - arguments 对象包含了 传入函数的所用实参
  - arguments 对象不是一个真正的数组 
    - **rest 参数(剩余参数) 是一个真正的数组 , 可以进行数组的所有的操作**
  - arguments是早起的ECMAScript中为了方便去获取所用参数提供的一个数据结构
    - **rest参数是ES6中提供并且希望以此来代替arguments**

# 箭头函数的补充

- 箭头函数是没有显示原型prototype的
  - 所以不能做作为构造函数, 使用new来创建对象
  - 箭头函数也不绑定this , arguments , super 参数



# 展开语法

- 可以在函数调用 / 数组构造时, 将数组表达式 或者 string 在语法层面展开
- 还可以在构造字面量对象时, 将对象表达式按 key- value 的方式展开
  - 在函数调用时使用
  - 在数组构造时使用
  - 在构建对象字面量时
    - 可以使用展开运算符
      - 这个是在ES9中添加的
- 展开运算符其实也是一种浅拷贝



# 浅拷贝

- 将一个obj对象中的内容复制给另一个info对象中
  - 但info对象中的内容发生改变时 , obj 对象中的内容不发生改变
    - 在内存中, 是又重新创建了一个堆内存, 两个对象的内地址不同
- 但是obj对象中还有对象
  - 这次浅拷贝在内存中复制时,
    - 将obj嵌套的对象完全复制给info对象,
      - 当info对象中嵌套对象发生更改时 , obj对象中嵌套的对象也同样发生更改

# 数值的表示

- 二进制 0b
- 八进制 0o
- 十六进制 0x
- 数字过长时, 可以使用_作为连接符



# Symbol的基本使用

- Symbol是ES6中新增的一个基本数据类型
  - Symbol : 符号
- ES6之前
  - 对象的属性名都是字符串形式 
    - 那么很容易造成属性名的冲突
  - 比如原来有一个对象
    - 我们希望在其中添加一个新的属性和值
      - 但是我们在不确定它原来内部有什么内容的情况下,
        - 很容易造成冲突 , 从而覆盖掉它内部的某个属性
- Symbol 就是为了 解决上面的问题 , 用来生成一个独一无二的值
  - Symbol 值 是通过**Symbol函数** 来生成的 , 生成后可以作为属性名
  - 在ES6之后
    - 对象的属性名可以使用字符串 , 也可以使用Symbol值
- Symbol 即使多次创建值, 它们也是不同的 
  - Symbol函数执行后每次创建出来的值都是独一无二的
- 我们也可以在创建Symbol值的时候传入一个描述descriptor



- Object.getOwnPropertSymbols
  - 遍历对象中的Symbol
- symbol.for方法
  - 可以创建相同的symbol
- symbol.keyFor方法
  - 可以获取对应的key

1. 只要是使用Symbol函数直接生成的值, 都是独一无二的
   - 不管描述是否是一样的
