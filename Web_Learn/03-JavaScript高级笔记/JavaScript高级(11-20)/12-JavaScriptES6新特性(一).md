# ECMAscript5的术语

- 执行上下文栈
  - 用于执行上下文的栈结构
- 执行上下文
  - 代码在执行之前会先创建对应的执行上下文
- 变量对象
  - 上下文关联的VO对象
    - VO对象 : 用于记录函数和变量声明
- 全局对象
  - 全局执行上下文关联的VO对象
- 激活对象
  - 函数执行上下文关联的VO对象
- 作用域链
  - 作用域链 , 用于关联指向上下文的变量查找



# 新的ECMA(ES6)代码执行描述

- 基本思路是相同的 , 只是对于一些词汇的描述发生了改变
- 执行上下文栈和执行上下文也是相同的 



## 词法环境 (Lexical Environment)

- 词法环境是一种规范类型 , 用于在词法嵌套结构中定义关联的变量 , 函数等标识符
- 一个词法环境是由环境记录 和一个外部词法环境组成
  - (就是词法环境关联环境记录)
  - outer :记录外部词法环境

- 一个词法环境经常用于关联一个函数声明 , 代码块语句 , try-catch语句
  - **当它们的代码被执行时**
    - **词法环境被创建出来**


- 现在的执行上下文不在关联VO, 和作用域链,  ,
  - 而关联的是词法环境

- 在ES5之后(ES6)  ,执行一个代码 , 通常会关联对应的词法环境
  - 执行上下文会关联两个词法环境
    - 一个是词法环境 一个是变量环境



## 词法环境 和 变量环境

## Lexical Environment and Variable Environment

**lexical environment 用于处理 let , const声明的标识符**

- 用于let 和 const 声明定义的变量
  - 它们会被作用域执行上下文的词法环境里面
    - 这些变量 和 包含 它们 的 **词法环境**就会被立刻创建
      - 但是不能访问
        - 直到变量被词法绑定 (就是真正给这个东西进行赋值)
      - 就是在没有赋值之前是不能被访问的 , 虽然创建出来了

**variable environment 用于处理var, function声明的标识符**



# 环境记录(Environment Record)

- 这ES6这个规范中有两种主要的环境记录值
  - 声明式环境记录
  - 对象环境记录
- 声明式环境记录
  - **记录状态**
  -  用于定义ECMAScript语言语法元素的效果
    - 如函数声明 , 变量声明
- 对象式环境记录
  - 对象环境记录用于定义ECMAScript元素的效果



# Let / Const 基本使用

- 从ES6开始新增了两个关键字可以声明变量
  - Let
  - Const
- **Let**
  - 直观来说, Let 和 var 是没有太大的区别 , 都是用于声明一个变量 ; 
- **Const**
  - const关键字是constant的单词的缩写
    - 表示常量 , 衡量 的意思
  - 它表示保存的数据一旦被赋值 , 就不能被更改
  - 但是如果赋值的是引用类型
    - 那么可以通过引用找到对应的对象
    - 修改对象的内容
- Let , Const不允许重复声明变量
  - 前提是在同一个作用域下

# Let / Const 作用域提升

Let , Const 和 Var的一个重要区别是作用域提升

- Var声明的变量是会进行作用域提升的
- 但是使用Let 和 Const声明的变量
  - 在声明之前访问会报错

Let 和 Const声明的变量会被创建

- 在包含它们的词法环境被实例化(创建)时
  - 但是 是 不可以访问它们的
  - 直到词法绑定被求值

意思 , 在访问之前就已经创建了 但是不能访问 , 只有赋值之后才可以访问

- 在执行上下文的词法环境创建出来的时候 , 变量事实上已经被创建了 , 只是这个变量是不能被访问的
- 作用域提升
  - 在声明变量的作用域中, 如果这个变量可以在声明之前被访问 , 那么我们可以称之为作用域提升
- 在let const 虽然被创建出来 ,但是不能被访问 , 我认为不能称之为作用域提升
- 观点
  - let const没有进行作用域提升 , 但是会再解析阶段被创建出来

## 暂时性死区

Let Const定义的标识符真正执行到声明的代码之前, 是不能被访问的

- 从块作用域的顶部一直到变量声明完成之前 , 这个变量处在暂时性死区 (TDZ temporal dead zone)
  - 使用术语 “ temporal” 是因为区域取决于执行顺序 ( 时间 ) ,而不是编写代码的位置



# Window对象添加属性

- 在全局通过var 来声明一个变量
  - 事实上会再window上添加一个属性
- 但是Let Const是不会给Window上添加任何属性的



# var的块级作用域

- 在ES5以及之前, 只有全局和函数会形成自己的作用域
  - 代码块对应的变量没有影响 (ES5)



# Let / Const 的块级作用域

- 在ES6开始 , 使用Let / Const / Class / Function声明的变量是有块级作用域
  - 但是function 函数 拥有块级作用域 , 但是在外面依然是可以访问的
  - 这是因为引擎会对函数的声明进行特殊的处理 , 
    - 允许想var 一样 在代码块 中也可以被外界访问



# var Let Const 的选择

- 对于Var使用
  - var所表出来的特殊性
    - 作用域提升
    - window全局对象
    - 没有块级作用域
  - 等都是历史遗漏问题
- 其实是JavaScript在设计之初的一种 语言缺陷
- 但市场上也在利用这种缺陷出一系列的面试题
- 对于Let , Const
  - Let 和Const 来说 , 是目前开发中推荐使用的
  - 我们会优先使用const 
    - 这样可以保证数据的安全性不会被随意的篡改
  - 只有当我们明确知道一个变量后续会需要被重新赋值时
    - 这使用Let
- 这也是在很多中语言里面也都是一种约定俗成的规范
  - 尽量也遵守这种规范





