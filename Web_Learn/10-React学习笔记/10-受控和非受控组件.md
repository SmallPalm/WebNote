受控组件（Controlled Components）

非受控组件（Uncontrolled Components）

是两种管理表单输入方式的不同方法。下面将详细介绍这两种组件的概念、用法以及它们的优缺点。

### 受控组件（Controlled Components）

**概念**： 受控组件是指表单元素的值由React组件的状态来控制。也就是说，表单元素的值始终由组件的状态（state）所驱动，通过事件处理器（如`onChange`）来更新状态。

**用法**： 在受控组件中，表单元素的值被赋值为组件的状态，并且每当表单元素的值发生变化时，都会调用事件处理器来更新组件的状态。

```react
import React, { useState } from 'react';

function ControlledComponent() {
  const [inputValue, setInputValue] = useState('');

  const handleChange = (event) => {
    setInputValue(event.target.value);
  };

  const handleSubmit = (event) => {
    event.preventDefault();
    alert('Submitted value: ' + inputValue);
  };

  return (
    <form onSubmit={handleSubmit}>
      <input
        type="text"
        value={inputValue}
        onChange={handleChange}
      />
      <button type="submit">Submit</button>
    </form>
  );
}

export default ControlledComponent;
```



**优点**：

1. 表单数据完全由React控制，确保了数据的一致性。
2. 可以很容易地进行表单数据验证和操作。
3. 状态驱动使得UI和数据逻辑分离更清晰。

**缺点**：

1. 对于复杂或大量表单元素，状态管理可能变得繁琐。
2. 每次输入变化都会导致组件重新渲染，可能影响性能。

### 非受控组件（Uncontrolled Components）

**概念**： 非受控组件是指表单元素的值不是由React组件的状态控制，而是通过直接访问DOM元素来获取当前值。

**用法**： 在非受控组件中，表单元素的值由React的`ref`属性来管理，通过`ref`获取表单元素的当前值。

```react
import React, { useRef } from 'react';

function UncontrolledComponent() {
  const inputRef = useRef(null);

  const handleSubmit = (event) => {
    event.preventDefault();
    alert('Submitted value: ' + inputRef.current.value);
  };

  return (
    <form onSubmit={handleSubmit}>
      <input
        type="text"
        ref={inputRef}
      />
      <button type="submit">Submit</button>
    </form>
  );
}

export default UncontrolledComponent;
```



**优点**：

1. 实现简单，对于小型表单或单个输入元素非常方便。
2. 不需要为每个输入元素创建状态变量，减少了代码量。
3. 由于不需要在每次输入变化时更新状态，性能可能更好。

**缺点**：

1. 表单数据的获取和操作不如受控组件直观，需要手动操作DOM。
2. 数据流可能变得不清晰，特别是在处理复杂表单逻辑时。
3. 难以实时验证和操作输入数据。

### 选择哪种组件？

选择受控组件还是非受控组件主要取决于具体的应用场景和需求：

- 如果需要对表单数据进行严格控制和验证，或需要在表单数据变化时执行复杂逻辑，推荐使用受控组件。
- 如果表单较简单或对性能有较高要求，可以考虑使用非受控组件。

有时，也可以混合使用两者，结合它们的优点。例如，在某些表单输入框使用非受控组件以提高性能，而在需要严格控制和验证的输入框使用受控组件。