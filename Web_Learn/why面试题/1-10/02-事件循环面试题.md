```js
async function async1() {
  // 同步
  console.log(1)
  await async2()
  console.log(3)
}
async function async2() {
  console.log(2)
}

console.log(4)

setTimeout(() => {
  console.log(5)
})

async1()

new Promise(resolve => {
  // 同步任务
  console.log(6)
  resolve()
}).then(res => {
  // 微任务
  console.log(7)
})

console.log(8)
```

**执行同步代码**：

- 代码从上到下开始执行，遇到第一个同步代码：`console.log(4)`，输出 `4`。
- 输出：`4`

**定义函数和异步操作**：

- 定义了 `async` 函数 `async1` 和 `async2`，以及 `setTimeout` 异步操作。此时它们只是被定义，并不会立即执行。

**设置 `setTimeout`**：

- `setTimeout` 被调用，但其回调函数会被放入宏任务队列中，并不会立即执行。

**调用 `async1()` 函数**：

- 调用 `async1()` 后，进入 `async1` 函数内部。
- 输出 `console.log(1)`，输出 `1`。
- 遇到 `await async2()`，会执行 `async2` 函数。

**执行 `async2()` 函数**：

- `async2()` 函数内部有一个同步的 `console.log(2)`，输出 `2`。
- 输出：`2`
- `async2()` 函数执行完后返回一个 `Promise` 对象（状态为`resolved`），此时控制权返回到 `async1()` 函数中的 `await` 语句，这时的 `await` 相当于让出线程，等待当前调用栈清空再继续执行。

**创建并立即执行 `Promise`**：

- 遇到一个新的 `Promise`，这个 `Promise` 会立即执行。
- 输出 `console.log(6)`，输出 `6`。
- 输出：`6`
- `resolve()` 被调用，`then` 回调被放入微任务队列中。

**输出 `console.log(8)`**：

- 继续执行同步代码，输出 `console.log(8)`，输出 `8`。
- 输出：`8`

**处理微任务队列**：

- 先前 `await` 之后的部分 `console.log(3)` 是一个微任务，当前同步任务执行完毕，开始执行微任务队列。
- 输出 `console.log(3)`，输出 `3`。
- 输出：`3`
- 执行 `Promise` 的 `then` 回调函数，输出 `console.log(7)`，输出 `7`。
- 输出：`7`

**处理宏任务队列**：

- 最后执行宏任务队列中的 `setTimeout` 回调函数，输出 `console.log(5)`，输出 `5`。
- 输出：`5`

## 解释：

1. 同步任务（`console.log(4)`）最先执行。
2. 遇到异步任务（`setTimeout`）时，先将其放入宏任务队列，随后继续执行同步任务（如`async1`）。
3. 在 `async` 函数中，`await` 的下一行代码会进入微任务队列，等待当前所有同步代码执行完毕后再执行。
4. 所有同步任务结束后，微任务队列中的任务（`await`之后的任务和 `Promise` 的 `then` 回调）会依次执行。
5. 最后，执行宏任务队列中的任务（`setTimeout` 的回调）。