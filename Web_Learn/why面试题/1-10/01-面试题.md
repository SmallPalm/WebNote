# JavaScript如何实现继承

JavaScript通过原型链实现继承

在构造函数中拥有自己的 Prototype

当子类构造函数通过Call方法调用父类的构造函数 实现继承

子类构造函数的Prototype作为父类构造函数的实例 实现继承

- 这个过程中，子类 构造函数的construction需要进行重新赋值到自己身上





# Jquery的优化方法

**减少DOM的访问**

- DOM 操作通常比内存操作要慢得多。

  - 尽量减少对 DOM 的访问次数，比如通过缓存 jQuery 选择器的结果。

- ```Js
  // 缓存选择器结果
  var $button = $('#button')
  $button.click(function() {
    // 操作
  })
  ```

**使用事件委托**

- 利用事件冒泡原理，将事件监听器绑定到父元素上，而不是每个子元素上。

- ```js
  $('ul').delegate('li', 'click', function() {
    // 处理点击事件
  })
  ```

**避免使用全局变量**

- 全局变量可能会污染全局命名空间，并可能导致意外的副作用。

**使用$函数选择DOM元素**

- 尽量使用 jQuery 的 `$` 函数来选择 DOM 元素
- 而不是直接使用 `document.getElementById` 或其他 DOM 方法

**链式调用**

- jQuery 支持链式调用，这可以减少代码量并提高可读性

- ```js
  $('#myDiv').hide().addClass('hidden');
  ```

**避免在循环中使用Jquery 方法**

- 在循环中使用 jQuery 方法可能会导致性能问题。
- 尝试在循环外部进行 DOM 操作。

**使用 `off()` 来移除事件监听器**

- 当不再需要某个事件监听器时，使用 `off()` 来移除它，以避免内存泄漏。

- ```js
  $button.off('click', handleClick); // 移除特定的事件监听器
  ```



# 列出Display的值, 并说明下它们的作用

display:  flex  : 定义flex布局

display: block : 块级元素

display: inline : 行内级元素

display: inline-block : 行内块级元素

display: none: 元素不被渲染

****

## 详细

display: flex;

- 定义一个弹性容器, 使得子元素可以进行弹性布局

display: block;

- 块级元素 : 宽度默认占满父元素的宽度 : 可以设置width, height

display: inline;

- 行内元素 : 同一行中与其他元素并排显示  设置width, height 无效

display: inline-block;

- 行内块级元素 : 结合了行内元素和块级元素的特点

display : none; 

- 隐藏元素 :  元素不会被渲染, 也不会占用空间

## 不常用

**`display: table;`**：元素被渲染为块级表格。它类似于一个块级元素，但具有表格的某些属性。

**`display: table-cell;`**：元素被渲染为表格单元格。通常与 `display: table;` 一起使用，以创建表格布局。

**`display: table-row;`**：元素被渲染为表格行。

**`display: table-row-group;`**：元素被渲染为表格行组，如 `<thead>`、`<tbody>` 或 `<tfoot>`。

**`display: grid;`**：定义一个网格容器，允许使用 CSS Grid 布局来放置子元素。

**`display: inline-grid;`**：元素被渲染为内联网格容器，类似于 `inline-block`，但使用网格布局。

**`display: list-item;`**：元素被渲染为列表项，通常与 `<ul>` 或 `<ol>` 元素一起使用。

**`display: run-in;`**：元素被渲染为“流入”块，其内容将与前面的内容合并，但具体行为可能因浏览器而异，并且不是所有浏览器都支持。



# link和@import的区别是什么

link标签 是 HTML标签, 在Head中使用

@import 是 CSS语法规则 , 在CSS文件内部开头使用



Link标签 不会阻止页面渲染 , 浏览器中并行下载多个CSS文件

@import 会阻止页面渲染 , 引入的CSS按顺序下载的

- 这意味着如果一个文件很大或者下载很慢，它可能会阻塞后续文件的下载和页面的渲染。



Link标签 : 适用于所有HTML版本

@import : 从CSS2引入的特性, 不适配旧浏览器



Link标签 容易维护和管理

@import :  CSS代码和引入的CSS文件混在一起, 会导致维护复杂度增加



Link 引入的样式表在层叠上下文中具有相同的优先级。

@import  引入的样式表的优先级可能会受到它在 CSS 文件中出现位置的影响。





##### 尽管 `@import` 有一些性能上的劣势，但在某些情况下，它仍然有其使用的理由：

- **组织大型项目**：在大型项目中，`@import` 可以用于模块化 CSS，将样式组织成多个文件，然后在一个主 CSS 文件中引入它们。
- **条件样式**：`@import` 可以在 CSS 文件中根据条件（如媒体查询）动态引入不同的样式表。
- **兼容性**：在一些特定的旧项目中，如果项目已经大量使用了 `@import`，并且没有计划迁移到其他方法，可能会继续使用它以保持一致性。

总的来说，推荐使用 `Link` 标签来引入 CSS，因为它提供了更好的性能和灵活性。然而，`@import` 可以作为特定情况下的一个有用工具。





# Route和Router的区别

Route是当前路由的状态对象，提供当前路由和路径，参数，查询等信息

提供的是，当前组件内容获取当前路由的相关信息

Router是全局路由的实例，用于控制全局路由

提供的是，整个应用程序的路由信息和导航方法



# Vue的六种通讯

props

$emit

Provide 和 inject

Vuex

EventBus

ref

pinia

attrs和listeners

$parent和 \$root

# Vue中key值的作用

在使用V-for循环时, 给每一个循环的元素添加一个key属性

用于vue内部优化diff算法时的优化

key的值是唯一的

根据 key 的 属性值 优化对DOM的操作

根据 key 的 属性值 避免组件/元素的重复渲染

根据 key 的 属性值来识别每个节点，从而在数据变化时尽可能地复用和重新排序现有元素，而不是重新创建所有元素。

****

# 详细

1. **优化 DOM 更新**：Vue 的虚拟 DOM 需要决定如何高效地更新 DOM。当使用 `v-for` 循环渲染列表时，Vue 会根据 `key` 属性值来识别每个节点，从而在数据变化时尽可能地复用和重新排序现有元素，而不是重新创建所有元素。
2. **避免组件/元素的重复渲染**：当列表数据发生变化时，如果元素有唯一的 `key`，Vue 可以通过 `key` 快速识别出哪些元素是新的、被删除的或者移动的，从而减少不必要的 DOM 操作和组件实例化。
3. **维护状态或子组件的活跃状态**：在使用 `v-for` 循环时，如果子组件或元素内部有状态（如输入框的内容），通过使用 `key`，Vue 可以确保即使数据变化导致 DOM 重新排序，这些状态也能正确地保持在对应的元素上。
4. **触发子组件的钩子函数**：当使用 `key` 时，Vue 会在必要时触发子组件的 `beforeDestroy` 和 `destroyed` 钩子函数，以便进行适当的清理工作。
5. **避免潜在的 bug**：如果没有使用 `key`，Vue 会使用一种更通用的方式来更新 DOM，这可能会导致一些难以追踪的 bug，尤其是在动态列表中。

`key` 的值应该是唯一的，并且最好是一个能够唯一标识列表中每一项的值，如数组索引或数据的唯一 ID。如果列表项的顺序可能会变化，或者列表项可能会被重复使用，使用 `key` 可以提供更好的性能和更稳定的行为。



# Vuex有哪几种属性

state: () =>({})

getter

mutation

action

modules