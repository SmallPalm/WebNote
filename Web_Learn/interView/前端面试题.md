# SSR除了服务器端渲染还有什么用

- 背景
  - 用户
    - 网站页面加载速度较慢,
      - 希望提升加载速度
    - 访问网站体验感较差



# Class extends是什么, 有什么作用

- Class是基于类的面向对象编程范式

- Class关键字用于定义一个类

- extends关键字是用于基础

  - 创建一个子类继承另一个类

  - 继承的时候还需要注意在constructor中

    - 需要调用父类的constructor

      ​	使用super()方法, 用来继承父类构造函数中的属性

作用

- 代码复用: 通过extends继承, 子类可以重用父类的代码
- 扩展功能: 子类可以继承父类的基础上添加新的属性和方法
- 多态性: 通过继承和多态性 ,可以创建能处理 **不同类型对象的通用代码**



# 实现数组的随机排序

- crypto.getRandomValues()方法来生成加密安全的随机数

- ```js
  function shuffleArray(array){
      for(let i = array.length - 1; i > 0; i--){
          // crypto.getRandomValues()方法来生成加密安全的随机数
          const j = crypto.getRandomValues(new Uint32Array(1))[0] % (i + 1);
          // Fisher-Yates洗牌算法来实现加密安全的数组随机排序
          [array[i], array[j]] = [array[j], array[i]];
      }
      return array
  }
  const myArray = [1, 2, 3, 4, 5, 6, 7, 8, 9]; 
  console.log(shuffleArray(myArray))
  ```

# 执行上下文有三种类型

- 全局执行上下文
  - 这是当程序首次运行时, 创建的唯一一个上下文
  - 在浏览器中, 全局执行上下文会创建一个全局对象
    - window对象
    - 并使this指向这个全局对象

- 函数执行上下文 (也称之为局部执行上下文)
  - 每当一个函数被调用时
    - 都会为这个函数创建一个新的执行上下文
  - 这意味着每次函数调用都会有一个与之关联的执行上下文
    - 这个上下文包含了函数执行时所需的所有信息
- Eval函数执行上下文
  - 执行一个字符串作为JavaScript代码执行
  - 是运行eval函数中的代码时创建的执行上下文
  - 不过，由于eval函数的使用存在一些安全性和性能问题
    - 因此在实际开发中建议尽量避免使用
  

# 调用栈和全局执行上下文栈

- 调用栈和全局执行上下栈并不完成相同

全局执行上下文栈是一个更广泛的概念

- 它包括**全局执行上下文**以及**函数调用创建的局部执行上下文**
- 在JavaScript中, 每一个**执行上下文**都与特定的代码块或函数**相关联**
  - 并存储了执行该代码块或函数所需要的所有信息
- 全局执行上下文是当JavaScript代码开始执行时**创建的第一个执行上下文**
  - 全局执行上下文包含了全局变量、函数声明等

- 当函数被调用时，会创建新的局部执行上下文并推入调用栈中

**调用栈主要用管理函数调用时的执行上下文**

- 一个函数被调用时, 一个新的局部执行上下文会被创建并推入到调用栈中
  - 这个局部执行上下文包含了函数执行时所需的所有信息
    - 如变量、函数声明、this值等
    - 当函数执行完成后
      - 它的局部执行上下文会从调用栈中弹出

总结

- 调用栈主要用于管理函数调用的执行上下文
- 全局执行上下文栈则包含了整个JavaScript程序的执行上下文
  - 包括全局执行上下文和由函数调用创建的局部执行上下文

## 全局执行上下文进入到调用栈中

- 在JavaScript中，当代码开始执行时
- 会首先创建一个全局执行上下文
  - 并将其推入调用栈中
- 全局执行上下文包含了全局变量、函数声明等
- 并且它的生命周期是整个程序的执行期间

调用栈是一个后进先出（LIFO）的数据结构

用于跟踪函数的调用顺序和执行流程

当函数被调用时

会创建一个新的执行上下文并将其推入调用栈中

一旦函数执行完毕并返回

其对应的执行上下文就会从调用栈中弹

# 调用栈和局部执行上下文

- **局部执行上下文**是函数执行时的具体环境
  - 局部执行上下文是**函数执行期间的一个临时环境**
  - 当函数执行完毕后，其对应的**局部执行上下文就会被销毁**。
- **调用栈: (又称为执行栈)**用于跟踪函数执行顺序的数据结构
  - 局部执行上下文是调用栈中的元素
  - 每个被调用的函数都会在**调用栈中创建一个与之对应的局部执行上下文**
  - 它按照后进先出（LIFO）的原则管理函数的调用和返回
  - 当程序执行一个函数时
    - 该函数的执行上下文会被创建
      - 并且这个执行上下文的相关信息会被推入调用栈中
  - 这个记录实际上就是该函数对应的局部执行上下文
  - 当函数执行完毕并**返回时**
    - 这个局部执行上下文会从调用栈中弹出
  - 调用栈的**主要作用**是确保函数按照正确的顺序执行
    - 并帮助管理函数之间的调用关系。



# 事件循环

- 事件循环的主要目的是让JavaScript能够以非堵塞的方式运行
  - 使JavaScript可以有序的执行任务
    - 并在适当的时间点响应用户的交互和其他系统的事件
  - 即使在执行耗时操作
  - 获取等待外部资源时, 也能保存响应

- 事件循环主要涉及到**调用栈**, **任务队列**, 以及**事件循环的迭代过程**

## **调用栈**

- 在JavaScript中, 代码执行是单线程的, 这意味着一次只能执行一段代码
  - 为了管理这些代码的执行顺序
  - 浏览器使用了调用栈
    - 当函数被调用时, **函数会被推入调用栈中等待执行**
    - 当函数执行完成后, 它会从调用栈中弹出

## 任务队列

浏览器中有两个主要的任务队列

- 宏任务队列 (macrotask queue) : 
  - 属于宏任务的
    - Ajax ,
    - setTimeout ,
    - setInterval 
    - setImmediate,
    - DOM监听 ,
    - Ul Rendering: UI渲染
- 微任务队列 (microtask queue) 
  - 属于微任务的
    - process.nextTick
    - Promise的then**回调**
    - Mutation Observe API 
      - 监听DOM的变化的
    - queueMicrotask() 
      - 直接加入到微任务队列中

## 事件循环

事件循环对于两个队列的优先级

- MainSrcipt 中的代码优先执行 (全局的代码) 
- 在执行任何一个宏任务之前 (不是队列 , 而是每一个宏任务)
  - 都会先查看微任务队列中是否会有任务需要执行
    - 宏任务执行之前 , 必须保证微任务队列是空的
    - 如果不为空 , 那么就优先执行微任务队列中的任务 ( 回调 )
    - 微任务队列为空后
    - 事件循环从宏任务队列中取出一个任务
      - 并将其推入调用栈执行
- 这个过程会一直重复，形成一个循环。

- 虽然事件循环使得浏览器能够同时处理多个任务

- 但并不意味着可以无限制地添加异步任务
- 过多的异步任务或长时间运行的任务可能导致浏览器性能下降或界面卡顿
- 因此，在编写JavaScript代码时
  - 需要合理管理和优化异步任务。



# Promise

- Promise是JavaScript中用于处理**异步操作**的编程模型
  - 提供一种可维护性的方式管理代码
  - 避免回调地狱的问题



## Promise的底层原理

- 主要涉及JavaScript的事件循环和微任务队列